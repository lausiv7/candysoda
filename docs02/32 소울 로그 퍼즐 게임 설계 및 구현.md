# 32. Sweet Puzzle 소울라이크 로그라이크 게임 설계 및 구현

## 📋 개요

기존 Sweet Puzzle 캔디 크러시 스타일 게임을 **소울라이크 + 로그라이크** 메커니즘으로 진화시켜 궁수의 전설 스타일 BM(비즈니스 모델)을 적용한 혁신적 퍼즐 게임 설계서입니다.

### 🎯 핵심 변화점

| 요소 | 기존 Sweet Puzzle | 소울 로그 퍼즐 변형 |
|------|------------------|-------------------|
| **실력 요소** | 퍼즐 매칭 + 시간 관리 | 퍼즐 패턴 분석 + 전략적 아이템 선택 |
| **성장 시스템** | 레벨별 별점 수집 | 전투력(장비) + 실력 지수 복합 |
| **진행 방식** | 순차적 레벨 클리어 | 로그라이크 런(세션) 기반 |
| **보상 구조** | 고정 레벨 보상 | 동적 3선택 룬(버프) 시스템 |
| **수익화** | 기본 아이템 구매 | 장비 가챠 + 에너지(번개) + 버프 재선택 |

## 🏗️ 게임 아키텍처 설계

### 1. 로그라이크 런(Run) 시스템

#### 1.1 런 구조
```
런 시작 → Stage 1-5 → 보스 스테이지 → 런 완료/실패
  ↓           ↓              ↓
룬 선택    각 스테이지      최종 보상
(3개중 1개) 클리어 후     (영구 장비)
           버프 선택
```

#### 1.2 스테이지 난이도 곡선 설계 (99번 문서 기반)

##### 승률 기반 구간별 설계
| Stage 구간 | 목표 승률(평균 유저) | 특징 | Sweet Puzzle 적용 |
|------------|---------------------|------|------------------|
| **1~5 런** | 80~95% | 튜토리얼, 패턴 학습, 난이도 완화 | 기본 3매치 학습, 특수블록 소개 |
| **6~20 런** | 55~75% | 아이템 사용 유도, 첫 과금 포인트 | 룬 선택의 중요성, 에너지 부족 경험 |
| **21~40 런** | 40~60% | 장비·버프 강화 필요, 보스 패턴 | 장비 가챠 필요성, 복합 퍼즐 패턴 |
| **41+ 런** | 35~50% | 고수·과금 유저 구간, 반복 수익 모델 | 엔드게임 콘텐츠, 시즌 리더보드 |

##### 동적 난이도 조정 공식
```javascript
// 31번 + 99번 문서 통합 공식
플레이어_실력 = 최근_5판_평균점수 / 스테이지_권장점수
플레이어_전투력 = 장비_스탯합 + 룬_버프합
효과적_전투력 = α * 플레이어_전투력 + β * 플레이어_실력

// Sweet Puzzle 특화 가중치 (99번 문서 승률 목표 반영)
α = 0.6 (장비 중요도)
β = 0.4 (실력 중요도)

// 구간별 목표 승률 반영한 성공 확률
목표_승률 = getTargetWinRate(currentStage); // 99번 문서 구간별 설정
성공확률 = 목표_승률 * sigmoid(효과적_전투력 / 스테이지_요구치)
k = 4 + (currentStage / 10) * 2 // 후반으로 갈수록 민감도 증가
```

### 2. 룬(버프) 시스템 설계

#### 2.1 룬 카테고리별 설계 (99번 문서 버프 시스템 적용)

##### 소모성 버프 (런 내 임시 효과)
| 룬 타입 | 효과 | 희귀도 | 99번 문서 기반 효과 |
|---------|------|--------|--------------------|
| **시간형** | 제한시간 확장 | Common | ⏳ 시간 연장 (+10~15초) |
| **힌트형** | 퍼즐 해법 제공 | Common | 🔍 힌트 제공 (최적 매치 표시) |
| **제거형** | 블록 즉시 제거 | Rare | 💣 블록 제거 (임의 블록 3개 제거) |
| **콤보형** | 점수/콤보 배율 증가 | Epic | 💥 콤보 배수 (콤보 점수 2배) |
| **생성형** | 특수블록 생성률 증가 | Rare | 🔥 파이어볼 마스터 (+20% 특수블록) |
| **전략형** | 시작 보너스 | Legendary | 🌟 룬 마스터 (시작시 특수블록 3개) |

##### 영구 장비 (99번 문서 장비 시스템)
| 장비 타입 | 효과 | 희귀도 | 99번 문서 기반 |
|-----------|------|--------|----------------|
| **망치 계열** | 매 판 시작시 랜덤 블록 제거 | Epic | 황금 퍼즐망치 원형 |
| **시계 계열** | 제한시간 기본 증가 | Rare | 마법 시계 (+5초 기본) |
| **부적 계열** | 버프 등장 확률 증가 | Legendary | 행운 부적 (+10% 버프 확률) |

#### 2.2 룬 선택 알고리즘
```python
def generate_rune_choices(player_performance, current_stage):
    # 플레이어 성능에 따른 적응형 룬 제안
    if player_performance < 0.7:  # 어려워하는 경우
        return [easy_rune, medium_rune, hard_rune]
    elif player_performance > 1.3:  # 너무 쉬워하는 경우
        return [medium_rune, hard_rune, legendary_rune]
    else:
        return [random_balanced_runes()]
```

### 3. 에너지(번개) 시스템 혁신

#### 3.1 번개 메커니즘 (99번 문서 체력 시스템)
- **회복 속도**: 30분당 1개 (99번 문서 기준, 하루 최대 48개)
- **최대 보유**: 5개
- **소모량**: 런 1회당 1개 (실패해도 소모)
- **런 시간**: 평균 3-5분 (99번 문서 한 판 기준) × 5스테이지 = 15-25분
- **과금 동기**: 99번 문서의 실패 루프 활용
  - 2~3회 연속 실패 시: 광고 시청 또는 소액 결제로 재도전
  - 보스 스테이지 직전: 장비 뽑기 팝업 노출

#### 3.2 번개 수익화 전략
```javascript
// 번개 부족 상황별 구매 확률 모델
purchase_probability = sigmoid(
  base_frustration +           // 기본 좌절감
  consecutive_failures * 0.8 + // 연속 실패
  energy_shortage * 1.2 +      // 번개 부족 시간
  rare_equipment_chance * 0.5  // 좋은 장비 획득 기회
)

// 가격 모델
번개_5개 = 1,000코인 (약 $0.99)
무제한_1시간 = 3,000코인 (약 $2.99)
무제한_1일 = 10,000코인 (약 $9.99)
```

## 🎮 게임플레이 메커니즘

### 4. 소울라이크 전투력 시스템

#### 4.1 장비 시스템 (영구)
```javascript
const equipment_types = {
  weapon: {
    name: "마법 지팡이",
    effect: "특수블록 생성률 +5%",
    rarity: ["Common", "Rare", "Epic", "Legendary"],
    upgrade_cost: base_cost * (1.6 ** level)
  },
  armor: {
    name: "수호자의 갑옷", 
    effect: "실패 시 번개 50% 확률로 보존",
    rarity_bonus: "Epic 이상시 100% 보존"
  },
  accessory: {
    name: "시간의 목걸이",
    effect: "시작시 +20초 보너스",
    set_bonus: "3개 착용시 모든 룬 효과 +25%"
  }
}
```

#### 4.2 전투력 계산
```javascript
function calculatePower(player) {
  let base_power = 100; // 기본 전투력
  let equipment_power = 0;
  let skill_bonus = 0;
  
  // 장비별 전투력 합산
  for (let item of player.equipment) {
    equipment_power += item.power * item.level * rarity_multiplier[item.rarity];
  }
  
  // 실력 보너스 (최근 성과 기반)
  skill_bonus = player.recent_performance * 50;
  
  return base_power + equipment_power + skill_bonus;
}
```

### 5. AI 기반 퍼즐 패턴 생성 시스템 (99-02번 문서 적용)

#### 5.1 패턴 뱅크 & 지능형 조합 시스템
```javascript
// 99-02번 문서 기반 패턴 뱅크 구조
const PatternBank = {
  primitives: [
    {
      id: "line3_horizontal",
      tags: ["line", "combo_opportunity"],
      base_difficulty: 1.2,
      learnability: 0.9,  // 0~1, 높을수록 빠르게 학습 가능
      params: {length: 3, direction: "horizontal"}
    },
    {
      id: "cluster4_square", 
      tags: ["cluster", "area_clear"],
      base_difficulty: 2.1,
      learnability: 0.8,
      params: {size: 4, shape: "square"}
    },
    {
      id: "gravity_shift_puzzle",
      tags: ["gravity", "timing_sensitive"],
      base_difficulty: 4.5,
      learnability: 0.5,  // 학습 어려움, 높은 신규성
      params: {shift_direction: "diagonal", duration: 3}
    }
  ]
};

// AI 하이브리드 패턴 생성기
function generateStagePattern(stage, userProfile, seed) {
  const targetDifficulty = computeTargetDifficulty(stage, userProfile);
  const rng = new SeededRandom(seed);
  const selectedPatterns = [];
  
  let currentDifficulty = 0;
  while (currentDifficulty < targetDifficulty) {
    const candidate = pickPrimitive(rng, {
      difficultyBudget: targetDifficulty - currentDifficulty,
      learnabilityBalance: computeLearnabilityBalance(selectedPatterns),
      noveltyWeight: 0.2  // 99-02 권장값
    });
    
    if (validatePatternCombination(candidate, selectedPatterns)) {
      selectedPatterns.push(candidate);
      currentDifficulty += candidate.base_difficulty;
    }
  }
  
  return assembleStageTemplate(selectedPatterns);
}
```

#### 5.2 학습 가능성 기반 난이도 조정 (99-02 핵심 철학)
```javascript
// 플레이어가 3~5판 내에 패턴을 파악할 수 있도록 설계
function ensureLearnability(stagePatterns, playerHistory) {
  const recentPerformance = analyzeRecentGames(playerHistory, 5);
  
  // 새로운 패턴 도입 시 학습 지원
  stagePatterns.forEach(pattern => {
    if (pattern.learnability < 0.6 && !playerHistory.hasSeenPattern(pattern.id)) {
      // 첫 경험 시 힌트 시스템 활성화
      pattern.addHintSupport = true;
      pattern.visualTelegraph = true;  // 시각적 예고 제공
    }
  });
  
  // 조합 복잡도 관리
  const combinationComplexity = calculateCombinationComplexity(stagePatterns);
  if (combinationComplexity > playerHistory.maxHandledComplexity * 1.3) {
    simplifyPatternInteraction(stagePatterns);
  }
  
  return stagePatterns;
}
```

#### 5.3 실시간 마이크로 DDA (99-02 미세조정 시스템)
```javascript
function applyMicroDDA(gameState, consecutiveFailures) {
  if (consecutiveFailures >= 3) {
    // 99-02: 미세하고 자연스러운 도움 제공
    const adjustments = {
      special_block_spawn_rate: gameState.special_block_rate * 1.1,
      hint_availability: true,
      pattern_telegraph_duration: gameState.telegraph_time * 1.2
    };
    
    // 'hand-holding' 느낌 방지 - 플레이어가 알아차리지 못할 정도로 미세
    if (adjustments.special_block_spawn_rate - gameState.special_block_rate < 0.05) {
      return applySubtleAdjustments(adjustments);
    }
  }
  
  return gameState;
}
```

#### 5.4 패턴 조합별 전략 요구사항 (99-02 기반 확장)
| 패턴 조합 | 학습성 | 전략 깊이 | Sweet Puzzle 적용 |
|-----------|--------|-----------|-------------------|
| **Line + Cluster 조합** | 높음 (0.85) | 중간 | 기본 콤보 체인, 순서 최적화 |
| **Gravity + Timing 조합** | 낮음 (0.6) | 높음 | 중력 변화 예측, 타이밍 매스터리 |
| **Teleport + Area 조합** | 중간 (0.7) | 높음 | 공간 인식, 다차원적 사고 |
| **Adaptive 조합** | 변동 (0.4-0.9) | 최고 | AI가 플레이어 스타일 분석 후 생성 |

#### 5.5 자동화 테스트 파이프라인 통합 (99-02 검증 시스템)
```javascript
// Monte Carlo + AI 플레이어 검증 시스템
async function validatePatternBalance() {
  const testResults = {
    monteCarlo: await runMonteCarloSimulation(100000, {
      playerTypes: ['beginner', 'average', 'expert'],
      stageRange: [1, 100],
      patternComplexity: 'all'
    }),
    
    aiPlayer: await runAIPlayerTest({
      heuristicPlayer: new HeuristicPuzzleAI(),
      reinforcementPlayer: new RLPuzzleAI(),
      testPatterns: PatternBank.getAllCombinations()
    }),
    
    abTesting: await setupABTest({
      controlGroup: 'current_generator_v1',
      testGroup: 'ai_enhanced_generator_v2', 
      metrics: ['d1_retention', 'd7_retention', 'conversion_rate']
    })
  };
  
  return generateBalanceReport(testResults);
}
```

## 🛒 수익화 (BM) 시스템

### 6. 3단계 수익화 구조

#### 6.1 에너지 기반 수익화 (1차)
```javascript
const energy_monetization = {
  problem: "번개 부족으로 플레이 중단",
  solution: "번개 구매 / 무제한 시간권",
  target_segment: "활성 플레이어 (DAU 30%)",
  conversion_rate: "8-12%",
  average_purchase: "$1.99"
}
```

#### 6.2 장비 가챠 수익화 (2차) - 99번 문서 튜닝 반영
```javascript
const gacha_system = {
  free_pull: "8시간마다 1회",
  paid_pull: "500코인 (1회), 4500코인 (10연)",
  pity_system: "50회마다 Epic 확정",
  rarity_rates: {
    common: "60%",
    rare: "25%", 
    epic: "12%",
    legendary: "3%"
  },
  target_revenue: "월매출의 60-70%",
  
  // 99번 문서 데이터 기반 튜닝 시스템
  auto_balancing: {
    monitor_metrics: ["평균 승률", "버프 사용 빈도", "과금 전환율"],
    adjustment_rules: {
      high_win_rate: "가챠 확률 조정으로 난이도 상승",
      low_win_rate: "장비 효과 상향으로 난이도 완화",
      low_conversion: "가격 및 효과 밸런스 재설정"
    }
  }
}
```

#### 6.3 편의성 수익화 (3차)
```javascript
const convenience_features = {
  rune_reroll: "광고 시청 또는 300코인으로 룬 재선택",
  continue: "실패한 런을 500코인으로 이어가기",
  double_reward: "클리어 보상 2배 (1000코인)",
  target_segment: "고과금 유저 (월 $50+ 지출)"
}
```

### 7. 플레이어 세그멘테이션 & 타겟팅

#### 7.1 플레이어 유형별 BM 전략
| 플레이어 타입 | 특징 | BM 전략 | 예상 LTV |
|--------------|------|---------|----------|
| **무과금 (F2P)** | 60% / 광고 시청 위주 | 광고 기반 수익, 소액 첫구매 유도 | $2-5 |
| **소과금 (Minnow)** | 30% / 월 $5-20 | 번개+간헐적 가챠 | $15-50 |
| **중과금 (Dolphin)** | 8% / 월 $20-100 | 정기 가챠+편의기능 | $100-300 |
| **고과금 (Whale)** | 2% / 월 $100+ | 프리미엄 패키지+VIP | $500+ |

#### 7.2 구매 동기 유발 시스템
```javascript
function triggerPurchaseOffer(player) {
  const frustration_score = 
    player.consecutive_failures * 2 +
    player.energy_shortage_time +
    (player.almost_won_stages * 1.5);
    
  const opportunity_score =
    player.current_streak +
    player.rare_equipment_nearby +
    player.leaderboard_position_threat;
    
  if (frustration_score > 5) {
    return show_energy_package();
  } else if (opportunity_score > 8) {
    return show_equipment_gacha();
  }
}
```

## 🎨 UI/UX 혁신 (궁수의 전설 스타일 차용)

### 8. 메인 허브 UI 설계

#### 8.1 로비 화면 구성
```
┌─────────────────────────────────┐
│  🍭 Sweet Soul Puzzle          │ ← 게임 타이틀
├─────────────────────────────────┤
│  ⚡️ 4/5    💰 12,500           │ ← 번개, 코인
│                                 │
│  🏃‍♂️ [START RUN]               │ ← 런 시작 (메인 버튼)
│     현재 전투력: 1,847          │
│     권장 전투력: 1,200          │ 
│                                 │
│  📦 [장비]  🎯 [가챠]          │ ← 주요 기능들
│  🏪 [상점]  🏆 [순위]          │
│                                 │
│  📅 일일 도전 (2/3 완료)        │ ← 이벤트 영역
│  🎪 한정 이벤트: 7일 남음       │
└─────────────────────────────────┘
```

#### 8.2 런 진행 UI
```
┌─────────────────────────────────┐
│ 런 진행도: ●●●○○ (3/5)         │
│ ⏰ 02:34  💰 +450  ⚡ 3/5      │
├─────────────────────────────────┤
│                                 │
│      [게임 보드 영역]           │
│         8x8 퍼즐               │
│                                 │
├─────────────────────────────────┤
│ 🎯 목표: 15,000점              │
│ 🌟 현재: 12,340점 (82%)        │
│                                 │
│ [💣] [🔥] [⚡] ← 액티브 스킬    │
└─────────────────────────────────┘
```

### 9. 룬 선택 시스템 UI

#### 9.1 3선택 룬 화면
```
┌─────────────────────────────────┐
│        🎊 스테이지 클리어! 🎊   │
│                                 │
│      다음 룬을 선택하세요       │
│                                 │
│ ┌─────────┐ ┌─────────┐ ┌─────────┐
│ │   ⏳    │ │   🔥    │ │   💥    │
│ │시간 연장 │ │파이어볼  │ │메가콤보 │
│ │  +15초  │ │생성+20% │ │데미지+35%│
│ │ Common  │ │  Rare   │ │  Epic   │
│ └─────────┘ └─────────┘ └─────────┘
│                                 │
│      💰 300코인으로 재선택?      │ ← 수익화 지점
└─────────────────────────────────┘
```

## 🔧 기술 구현 가이드

### 10. 기존 Sweet Puzzle 코드 베이스 확장

#### 10.1 핵심 클래스 확장
```typescript
// 기존: GameBoard.ts 확장
class SoulLikeGameBoard extends GameBoard {
  public runes: RuneEffect[] = [];
  public playerPower: number = 100;
  public currentRunProgress: RunProgress;
  
  // 룬 효과 적용
  applyRuneEffects() {
    for (let rune of this.runes) {
      switch (rune.type) {
        case RuneType.TIME_EXTENSION:
          this.gameTime += rune.value;
          break;
        case RuneType.SPECIAL_BLOCK_BOOST:
          this.specialBlockRate *= (1 + rune.value);
          break;
      }
    }
  }
}
```

#### 10.2 AI 패턴 생성 시스템 클래스 (99-02 기반)
```typescript
// PatternGenerator.ts - AI 기반 퍼즐 패턴 생성기
class AIPatternGenerator {
  private patternBank: PatternBank;
  private learningEngine: PatternLearningEngine;
  
  constructor() {
    this.patternBank = new PatternBank();
    this.learningEngine = new PatternLearningEngine();
  }
  
  // 99-02: 학습 가능성을 고려한 패턴 생성
  async generateStagePattern(stage: number, playerProfile: PlayerProfile): Promise<StagePattern> {
    const targetDifficulty = this.computeTargetDifficulty(stage, playerProfile);
    const seed = this.generateSeed(stage, playerProfile.id);
    
    // 규칙 기반 + ML 하이브리드 선택
    const candidatePatterns = await this.hybridPatternSelection({
      targetDifficulty,
      playerHistory: playerProfile.gameHistory,
      learnabilityThreshold: 0.3,  // 99-02 권장 최소값
      noveltyWeight: 0.2
    });
    
    // 학습 가능성 검증
    const validatedPatterns = this.ensureLearnability(candidatePatterns, playerProfile);
    
    return this.assembleStageTemplate(validatedPatterns, seed);
  }
  
  // 99-02: 실시간 마이크로 DDA
  applyMicroDDA(gameState: GameState, performanceMetrics: PerformanceMetrics): GameState {
    if (performanceMetrics.consecutiveFailures >= 3) {
      // 미세하고 자연스러운 조정
      const adjustments = {
        hintAvailability: true,
        patternTelegraphDuration: gameState.telegraphTime * 1.15,
        specialBlockSpawnRate: Math.min(gameState.specialBlockRate * 1.05, 0.3)
      };
      
      return this.applySubtleAdjustments(gameState, adjustments);
    }
    
    return gameState;
  }
}

// RunManager.ts - 런 진행 관리 (AI 패턴 생성기 통합)
class RunManager {
  private currentStage: number = 1;
  private selectedRunes: Rune[] = [];
  private runStartTime: Date;
  private patternGenerator: AIPatternGenerator;  // 99-02 추가
  
  constructor() {
    this.patternGenerator = new AIPatternGenerator();
  }
  
  async startRun(playerProfile: PlayerProfile): Promise<RunResult> {
    // 에너지 차감
    await EnergyManager.consumeEnergy(1);
    
    // AI 생성 패턴으로 스테이지 시작
    for (let stage = 1; stage <= 5; stage++) {
      // 99-02: 개인화된 패턴 생성
      const stagePattern = await this.patternGenerator.generateStagePattern(stage, playerProfile);
      
      const result = await this.playStageWithPattern(stage, stagePattern);
      if (!result.success) {
        return this.handleRunFailure();
      }
      
      // 룬 선택 (보스 제외)
      if (stage < 5) {
        const selectedRune = await this.showRuneSelection();
        this.selectedRunes.push(selectedRune);
      }
      
      // 99-02: 학습 데이터 수집
      await this.collectLearningData(stage, stagePattern, result);
    }
    
    return this.completeRun();
  }
}

#### 10.3 BM 시스템 구현
```typescript
// PurchaseManager.ts
class PurchaseManager {
  // 31번 문서 공식 적용
  calculatePurchaseProbability(player: Player): number {
    const pf = Math.max(0, 1 - player.performanceGap); // Progress Friction
    const ls = player.lossStreak; // Loss Streak
    const rs = player.energyShortageHours; // Resource Scarcity
    const rm = this.getCurrentOfferValue(); // Reward Magnitude
    const pvs = player.spendingSegment; // Player Value Segment
    const success = player.recentSuccessCount;
    
    // 31번 문서 로지스틱 회귀 모델
    const logit = -3.0 + 2.0*pf + 0.5*ls + 1.5*rs + 1.0*rm + 2.5*pvs - 1.0*success;
    
    return 1 / (1 + Math.exp(-logit));
  }
  
  async showDynamicOffer(player: Player) {
    const probability = this.calculatePurchaseProbability(player);
    
    if (probability > 0.15) {  // 15% 이상일 때만 제안
      if (player.energyShortageHours > 2) {
        return this.showEnergyPackage();
      } else if (player.lossStreak > 3) {
        return this.showPowerUpPackage(); 
      }
    }
  }
}
```

### 11. AI 패턴 생성 데이터 모델링 (99-02 기반)

#### 11.1 플레이어 프로필 확장 (학습 데이터 포함)
```typescript
interface AIEnhancedPlayerProfile extends SoulLikePlayer {
  // 기존 전투력 관련
  equipment: Equipment[];
  totalPower: number;
  skillRating: number;
  
  // 런 진행
  currentRun?: RunSession;
  runHistory: RunResult[];
  
  // 99-02: AI 학습을 위한 패턴 데이터
  patternLearningData: {
    seenPatterns: Map<string, PatternExperience>;
    learningCurve: LearningCurveData[];
    preferredStrategies: StrategyProfile[];
    maxHandledComplexity: number;
    adaptabilityScore: number;  // 0~1, 새로운 패턴 적응 속도
  };
  
  // BM 관련
  energyCount: number;
  lastEnergyRecharge: Date;
  purchaseHistory: Purchase[];
  spendingTier: 'f2p' | 'minnow' | 'dolphin' | 'whale';
  
  // 99-02: 성능 지표 (AI 분석용)
  lossStreak: number;
  recentPerformance: PerformanceMetrics[];
  frustrationLevel: number;
  engagementScore: number;  // 패턴에 대한 몰입도
}

// 99-02: 패턴 경험 데이터
interface PatternExperience {
  patternId: string;
  encounterCount: number;
  successRate: number;
  averageTimeToSolve: number;
  learningProgression: number[];  // 시간별 성능 향상 곡선
  lastEncountered: Date;
  masteryLevel: 'novice' | 'learning' | 'competent' | 'master';
}
```

#### 11.2 AI 패턴 뱅크 데이터 구조
```typescript
interface PatternPrimitive {
  id: string;
  tags: PatternTag[];
  baseDifficulty: number;
  learnability: number;  // 99-02 핵심: 0~1, 학습 용이성
  novelty: number;       // 0~1, 신규성 점수
  params: PatternParams;
  
  // 99-02: 조합 규칙
  spawnRules: {
    requiresMinMoves?: number;
    forbiddenWithTags?: PatternTag[];
    prerequisitePatterns?: string[];
    maxSimultaneous?: number;
  };
  
  // 99-02: 학습 지원
  supportSystems: {
    visualTelegraph?: boolean;
    hintAvailable?: boolean;
    practiceMode?: boolean;
    tutorialPhases?: TutorialPhase[];
  };
}

interface StagePattern {
  id: string;
  primitives: PatternPrimitive[];
  totalDifficulty: number;
  totalLearnability: number;
  combinationComplexity: number;
  
  // 99-02: 동적 조정 데이터
  ddaState: {
    baseState: GameState;
    adjustmentHistory: DDAadjustment[];
    playerFeedbackLoop: FeedbackMetrics;
  };
  
  // 99-02: 검증 데이터
  validationResults?: {
    monteCarloResults: SimulationResult[];
    aiPlayerResults: AITestResult[];
    playerTestResults?: RealPlayerTestResult[];
  };
}
  puzzlePattern: PuzzlePattern;
  timeLimit: number;
  targetScore: number;
  specialConditions?: SpecialCondition[];
}
```

## 📊 밸런싱 및 시뮬레이션 계획

### 12. 자동 밸런싱 시스템

#### 12.1 31번 문서 시뮬레이터 적용
```python
# Sweet Puzzle 특화 시뮬레이션 파라미터
SIMULATION_CONFIG = {
    "player_segments": {
        "f2p": {"power_mean": 150, "skill_mean": 0.6, "pvs": 1.0},
        "minnow": {"power_mean": 250, "skill_mean": 0.7, "pvs": 2.0}, 
        "dolphin": {"power_mean": 400, "skill_mean": 0.8, "pvs": 3.5},
        "whale": {"power_mean": 800, "skill_mean": 0.9, "pvs": 5.0}
    },
    "stage_requirements": [100, 120, 144, 173, 220],  # 보스까지
    "rune_effects": {
        "time_extension": 0.15,    # 15% 성공률 증가
        "special_boost": 0.20,     # 20% 성공률 증가  
        "combo_master": 0.25       # 25% 성공률 증가
    }
}
```

#### 12.2 A/B 테스트 계획
| 테스트 항목 | A그룹 | B그룹 | 측정 지표 |
|------------|--------|--------|-----------|
| **에너지 회복** | 25분/개 | 30분/개 | 세션 길이, 구매율 |
| **룬 선택 수** | 3개 중 선택 | 4개 중 선택 | 선택 만족도, 리텐션 |
| **가챠 확률** | Epic 12% | Epic 15% | 매출, 유저 만족도 |
| **첫구매 할인** | 50% 할인 | 70% 할인 | 전환율, LTV |

## 🚀 개발 로드맵

### Phase 1: 핵심 로그라이크 시스템 (4-6주)
- [ ] RunManager, StageManager 구현
- [ ] 룬 시스템 및 3선택 UI
- [ ] 기본 장비 시스템
- [ ] 에너지 시스템

### Phase 2: BM 시스템 (4주)
- [ ] 가챠 시스템
- [ ] 구매 동기 분석 시스템
- [ ] 결제 연동 (Google Play Billing)
- [ ] 광고 SDK 연동

### Phase 3: 밸런싱 및 최적화 (3-4주) 
- [ ] 시뮬레이션 시스템 구축
- [ ] A/B 테스트 프레임워크
- [ ] 실시간 밸런싱 도구
- [ ] 운영 대시보드

### Phase 4: 소프트 런칭 (2-3주)
- [ ] 제한된 지역 출시
- [ ] 실사용자 데이터 수집
- [ ] 밸런싱 조정
- [ ] 버그 수정 및 최적화

## 📈 성공 지표 (KPI) 정의

### 수익 지표
- **ARPU**: 월 $3-5 (목표)
- **전환율**: 12-18% (F2P → 과금)
- **D7 매출**: 신규 유저당 $0.8-1.2

### 게임플레이 지표  
- **D1/D7/D30 리텐션**: 45%/20%/8%
- **평균 세션**: 12-15분
- **일일 런 수**: 4-8회
- **런 완주율**: 35-50%

### 사용자 만족도
- **스토어 평점**: 4.2+ 별점
- **NPS**: +30 이상
- **리뷰 키워드**: "중독적", "전략적", "공정함"

---

Sweet Puzzle의 소울라이크 로그라이크 변형은 **99-01번 문서의 공정한 레벨 디자인**과 **31번 문서의 수학적 정밀성**을 결합하여, 기존 캔디 크러시 장르에 **전략적 깊이와 진정한 공정성**을 추가합니다.

**공정성 혁신 포인트**:
- **실력 중심 설계**: 70% 실력, 30% 장비로 공정한 성장 경험
- **성취감 기반 수익화**: 실패 처벌 대신 성취 도달 축하 모델
- **레벨 디자인 기반 난이도**: 구간별 목표 승률로 예측 가능한 도전
- **선택적 지원**: 강요 대신 도움 제안, 자연 회복 기다리기 옵션 제공
- **AI 기반 밸런싱**: 3유형 시뮬레이션으로 모든 플레이어에게 공정한 경험

궁수의 전설의 수익성을 **99-01번 문서의 윤리적 비즈니스 모델**로 진화시켜, **지속 가능한 수익성과 진정한 사용자 만족**을 동시에 달성하는 차세대 윤리적 모바일 게임이 탄생할 것입니다.

**🎯 최종 목표: Sweet Puzzle Fair Edition - 공정한 레벨 디자인과 이타적 비즈니스 모델로 월매출 $100K+ 달성 가능한 지속 가능 프리미엄 퍼즐 게임**