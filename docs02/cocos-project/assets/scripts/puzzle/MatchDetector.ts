/**
 * [의도] Sweet Puzzle 게임의 매치 감지 시스템을 TypeScript/Cocos Creator로 구현
 * [책임] 3매치 이상 블록 패턴 감지, L/T 모양 매치 감지, 특수 블록 생성 조건 판단
 */

import { _decorator, Component } from 'cc';
import { GameBoard } from './GameBoard';
import { Block } from './Block';
import { BlockType, SpecialBlockType, BlockPosition, BlockTypeHelper } from './BlockType';

const { ccclass } = _decorator;

// 매치 타입 정의
export enum MatchType {
    HORIZONTAL = 'horizontal',
    VERTICAL = 'vertical',
    L_SHAPE = 'l_shape',
    T_SHAPE = 't_shape',
    CROSS = 'cross'
}

// 매치 정보를 담는 클래스
export class Match {
    public type: MatchType;
    public blocks: Block[];
    public length: number;
    public score: number;
    public specialBlockType: SpecialBlockType;
    public centerPosition: BlockPosition | null;
    
    constructor(type: MatchType, blocks: Block[], length: number, score: number = 0) {
        this.type = type;
        this.blocks = blocks;
        this.length = length;
        this.score = score;
        this.specialBlockType = SpecialBlockType.NONE;
        this.centerPosition = this.calculateCenterPosition();
    }
    
    /**
     * [의도] 매치된 블록들의 위치 배열 반환
     */
    public getPositions(): BlockPosition[] {
        return this.blocks.map(block => ({ x: block.position.x, y: block.position.y }));
    }
    
    /**
     * [의도] 매치의 중심 위치 계산
     */\n    private calculateCenterPosition(): BlockPosition | null {\n        if (this.blocks.length === 0) return null;\n        \n        const avgX = this.blocks.reduce((sum, block) => sum + block.position.x, 0) / this.blocks.length;\n        const avgY = this.blocks.reduce((sum, block) => sum + block.position.y, 0) / this.blocks.length;\n        \n        return { \n            x: Math.round(avgX), \n            y: Math.round(avgY) \n        };\n    }\n    \n    /**\n     * [의도] 매치된 블록의 타입 반환\n     */\n    public getBlockType(): BlockType {\n        return this.blocks.length > 0 ? this.blocks[0].blockType : BlockType.EMPTY;\n    }\n    \n    /**\n     * [의도] 매치 정보 문자열 반환 (디버깅용)\n     */\n    public toString(): string {\n        return `Match(${this.type}, ${this.length}개, ${this.getBlockType()}, score:${this.score})`;\n    }\n}\n\n@ccclass('MatchDetector')\nexport class MatchDetector extends Component {\n    \n    private gameBoard: GameBoard = null!;\n    private matchCache: Map<string, Match[]> = new Map();\n    private lastBoardHash: string = '';\n    \n    // 매치 감지 설정\n    private readonly MIN_MATCH_LENGTH = 3;\n    private readonly MAX_CACHE_SIZE = 100;\n    \n    /**\n     * [의도] 매치 감지기 초기화\n     */\n    public initialize(gameBoard: GameBoard): void {\n        this.gameBoard = gameBoard;\n        this.matchCache.clear();\n        this.lastBoardHash = '';\n        \n        console.log('[MatchDetector] 초기화 완료');\n    }\n    \n    /**\n     * [의도] 모든 매치 찾기 (메인 함수)\n     */\n    public findAllMatches(): Match[] {\n        // 보드 상태 해시를 통한 캐싱 최적화\n        const currentBoardHash = this.getBoardHash();\n        if (this.lastBoardHash === currentBoardHash && this.matchCache.has(currentBoardHash)) {\n            const cachedResult = this.matchCache.get(currentBoardHash)!;\n            console.log(`[MatchDetector] 캐시된 결과 사용: ${cachedResult.length}개 매치`);\n            return cachedResult;\n        }\n        \n        const matches: Match[] = [];\n        \n        // 수평 매치 검사\n        matches.push(...this.findHorizontalMatches());\n        \n        // 수직 매치 검사  \n        matches.push(...this.findVerticalMatches());\n        \n        // L/T 모양 복합 매치 검사\n        matches.push(...this.findShapeMatches());\n        \n        // 중복 제거 및 우선순위 정렬\n        const uniqueMatches = this.removeDuplicateMatches(matches);\n        \n        // 특수 블록 생성 조건 확인 및 점수 계산\n        for (const match of uniqueMatches) {\n            match.specialBlockType = this.determineSpecialBlockType(match);\n            match.score = this.calculateMatchScore(match);\n        }\n        \n        // 결과 캐싱\n        this.cacheResult(currentBoardHash, uniqueMatches);\n        this.lastBoardHash = currentBoardHash;\n        \n        console.log(`[MatchDetector] 매치 감지 완료: ${uniqueMatches.length}개 발견`);\n        return uniqueMatches;\n    }\n    \n    /**\n     * [의도] 수평 매치 찾기\n     */\n    private findHorizontalMatches(): Match[] {\n        const matches: Match[] = [];\n        \n        for (let y = 0; y < this.gameBoard.config.height; y++) {\n            let currentSequence: Block[] = [];\n            let currentType: BlockType = BlockType.EMPTY;\n            \n            for (let x = 0; x < this.gameBoard.config.width; x++) {\n                const block = this.gameBoard.getBlockAt(x, y);\n                \n                if (block && \n                    block.blockType !== BlockType.EMPTY && \n                    BlockTypeHelper.isNormalBlock(block.blockType)) {\n                    \n                    if (block.blockType === currentType) {\n                        // 같은 타입 연속\n                        currentSequence.push(block);\n                    } else {\n                        // 타입 변경 - 이전 시퀀스 확인\n                        if (currentSequence.length >= this.MIN_MATCH_LENGTH) {\n                            matches.push(new Match(\n                                MatchType.HORIZONTAL, \n                                [...currentSequence], \n                                currentSequence.length\n                            ));\n                        }\n                        \n                        // 새 시퀀스 시작\n                        currentSequence = [block];\n                        currentType = block.blockType;\n                    }\n                } else {\n                    // 블록이 없거나 매치 불가능 - 시퀀스 중단\n                    if (currentSequence.length >= this.MIN_MATCH_LENGTH) {\n                        matches.push(new Match(\n                            MatchType.HORIZONTAL, \n                            [...currentSequence], \n                            currentSequence.length\n                        ));\n                    }\n                    currentSequence = [];\n                    currentType = BlockType.EMPTY;\n                }\n            }\n            \n            // 행 끝에서 시퀀스 확인\n            if (currentSequence.length >= this.MIN_MATCH_LENGTH) {\n                matches.push(new Match(\n                    MatchType.HORIZONTAL, \n                    [...currentSequence], \n                    currentSequence.length\n                ));\n            }\n        }\n        \n        return matches;\n    }\n    \n    /**\n     * [의도] 수직 매치 찾기\n     */\n    private findVerticalMatches(): Match[] {\n        const matches: Match[] = [];\n        \n        for (let x = 0; x < this.gameBoard.config.width; x++) {\n            let currentSequence: Block[] = [];\n            let currentType: BlockType = BlockType.EMPTY;\n            \n            for (let y = 0; y < this.gameBoard.config.height; y++) {\n                const block = this.gameBoard.getBlockAt(x, y);\n                \n                if (block && \n                    block.blockType !== BlockType.EMPTY && \n                    BlockTypeHelper.isNormalBlock(block.blockType)) {\n                    \n                    if (block.blockType === currentType) {\n                        currentSequence.push(block);\n                    } else {\n                        if (currentSequence.length >= this.MIN_MATCH_LENGTH) {\n                            matches.push(new Match(\n                                MatchType.VERTICAL, \n                                [...currentSequence], \n                                currentSequence.length\n                            ));\n                        }\n                        \n                        currentSequence = [block];\n                        currentType = block.blockType;\n                    }\n                } else {\n                    if (currentSequence.length >= this.MIN_MATCH_LENGTH) {\n                        matches.push(new Match(\n                            MatchType.VERTICAL, \n                            [...currentSequence], \n                            currentSequence.length\n                        ));\n                    }\n                    currentSequence = [];\n                    currentType = BlockType.EMPTY;\n                }\n            }\n            \n            if (currentSequence.length >= this.MIN_MATCH_LENGTH) {\n                matches.push(new Match(\n                    MatchType.VERTICAL, \n                    [...currentSequence], \n                    currentSequence.length\n                ));\n            }\n        }\n        \n        return matches;\n    }\n    \n    /**\n     * [의도] L자, T자 모양 매치 찾기\n     */\n    private findShapeMatches(): Match[] {\n        const matches: Match[] = [];\n        \n        for (let y = 1; y < this.gameBoard.config.height - 1; y++) {\n            for (let x = 1; x < this.gameBoard.config.width - 1; x++) {\n                const centerBlock = this.gameBoard.getBlockAt(x, y);\n                if (!centerBlock || !BlockTypeHelper.isNormalBlock(centerBlock.blockType)) {\n                    continue;\n                }\n                \n                // T자 모양 검사 (상하좌우 모든 방향)\n                const tShapeMatch = this.checkTShapeAt(x, y, centerBlock.blockType);\n                if (tShapeMatch) {\n                    matches.push(tShapeMatch);\n                }\n                \n                // L자 모양 검사 (4개 코너 방향)\n                const lShapeMatches = this.checkLShapeAt(x, y, centerBlock.blockType);\n                matches.push(...lShapeMatches);\n            }\n        }\n        \n        return matches;\n    }\n    \n    /**\n     * [의도] T자 모양 매치 확인\n     */\n    private checkTShapeAt(x: number, y: number, blockType: BlockType): Match | null {\n        const centerBlock = this.gameBoard.getBlockAt(x, y)!;\n        \n        // T자 모양: 중심에서 3방향으로 뻗어나가는 형태\n        const directions = [\n            // 위쪽 T (┴)\n            { main: [{x: 0, y: -1}, {x: 0, y: -2}], side: [{x: -1, y: 0}, {x: 1, y: 0}] },\n            // 아래쪽 T (┬)\n            { main: [{x: 0, y: 1}, {x: 0, y: 2}], side: [{x: -1, y: 0}, {x: 1, y: 0}] },\n            // 왼쪽 T (├)\n            { main: [{x: -1, y: 0}, {x: -2, y: 0}], side: [{x: 0, y: -1}, {x: 0, y: 1}] },\n            // 오른쪽 T (┤)\n            { main: [{x: 1, y: 0}, {x: 2, y: 0}], side: [{x: 0, y: -1}, {x: 0, y: 1}] }\n        ];\n        \n        for (const direction of directions) {\n            const matchedBlocks = [centerBlock];\n            let validMatch = true;\n            \n            // 메인 방향 확인\n            for (const offset of direction.main) {\n                const block = this.gameBoard.getBlockAt(x + offset.x, y + offset.y);\n                if (block && block.blockType === blockType) {\n                    matchedBlocks.push(block);\n                } else {\n                    validMatch = false;\n                    break;\n                }\n            }\n            \n            // 사이드 방향 확인\n            if (validMatch) {\n                for (const offset of direction.side) {\n                    const block = this.gameBoard.getBlockAt(x + offset.x, y + offset.y);\n                    if (block && block.blockType === blockType) {\n                        matchedBlocks.push(block);\n                    } else {\n                        validMatch = false;\n                        break;\n                    }\n                }\n            }\n            \n            if (validMatch && matchedBlocks.length >= 5) {\n                return new Match(MatchType.T_SHAPE, matchedBlocks, matchedBlocks.length);\n            }\n        }\n        \n        return null;\n    }\n    \n    /**\n     * [의도] L자 모양 매치 확인\n     */\n    private checkLShapeAt(x: number, y: number, blockType: BlockType): Match[] {\n        const matches: Match[] = [];\n        const centerBlock = this.gameBoard.getBlockAt(x, y)!;\n        \n        // L자 모양: 4개 코너 방향\n        const lShapes = [\n            // 좌상 L (└)\n            [{x: -1, y: 0}, {x: -2, y: 0}, {x: 0, y: -1}, {x: 0, y: -2}],\n            // 우상 L (┘)\n            [{x: 1, y: 0}, {x: 2, y: 0}, {x: 0, y: -1}, {x: 0, y: -2}],\n            // 좌하 L (┌)\n            [{x: -1, y: 0}, {x: -2, y: 0}, {x: 0, y: 1}, {x: 0, y: 2}],\n            // 우하 L (┐)\n            [{x: 1, y: 0}, {x: 2, y: 0}, {x: 0, y: 1}, {x: 0, y: 2}]\n        ];\n        \n        for (const shape of lShapes) {\n            const matchedBlocks = [centerBlock];\n            let validMatch = true;\n            \n            for (const offset of shape) {\n                const block = this.gameBoard.getBlockAt(x + offset.x, y + offset.y);\n                if (block && block.blockType === blockType) {\n                    matchedBlocks.push(block);\n                } else {\n                    validMatch = false;\n                    break;\n                }\n            }\n            \n            if (validMatch && matchedBlocks.length >= 5) {\n                matches.push(new Match(MatchType.L_SHAPE, matchedBlocks, matchedBlocks.length));\n            }\n        }\n        \n        return matches;\n    }\n    \n    /**\n     * [의도] 중복 매치 제거 및 우선순위 정렬\n     */\n    private removeDuplicateMatches(matches: Match[]): Match[] {\n        const uniqueMatches: Match[] = [];\n        const usedBlocks = new Set<string>();\n        \n        // 길이와 타입별로 우선순위 정렬 (긴 매치, 특수 모양 우선)\n        matches.sort((a, b) => {\n            // 길이 우선\n            if (a.length !== b.length) {\n                return b.length - a.length;\n            }\n            \n            // 모양 타입 우선순위\n            const typeOrder = {\n                [MatchType.T_SHAPE]: 4,\n                [MatchType.L_SHAPE]: 3,\n                [MatchType.CROSS]: 2,\n                [MatchType.VERTICAL]: 1,\n                [MatchType.HORIZONTAL]: 0\n            };\n            \n            return typeOrder[b.type] - typeOrder[a.type];\n        });\n        \n        for (const match of matches) {\n            const matchBlocks = match.blocks.map(block => `${block.position.x},${block.position.y}`);\n            \n            // 이미 사용된 블록이 있는지 확인\n            const hasUsedBlock = matchBlocks.some(blockKey => usedBlocks.has(blockKey));\n            \n            if (!hasUsedBlock) {\n                uniqueMatches.push(match);\n                matchBlocks.forEach(blockKey => usedBlocks.add(blockKey));\n            }\n        }\n        \n        return uniqueMatches;\n    }\n    \n    /**\n     * [의도] 특수 블록 생성 타입 결정\n     */\n    private determineSpecialBlockType(match: Match): SpecialBlockType {\n        return BlockTypeHelper.getSpecialBlockType(match.length, match.type);\n    }\n    \n    /**\n     * [의도] 매치 점수 계산\n     */\n    private calculateMatchScore(match: Match): number {\n        const baseScore = 100;\n        const lengthMultiplier = match.length - 2; // 3매치 = 1, 4매치 = 2, ...\n        \n        let typeMultiplier = 1;\n        switch (match.type) {\n            case MatchType.T_SHAPE:\n            case MatchType.CROSS:\n                typeMultiplier = 3;\n                break;\n            case MatchType.L_SHAPE:\n                typeMultiplier = 2;\n                break;\n            default:\n                typeMultiplier = 1;\n        }\n        \n        return baseScore * lengthMultiplier * typeMultiplier;\n    }\n    \n    /**\n     * [의도] 보드 상태 해시 생성 (캐싱용)\n     */\n    private getBoardHash(): string {\n        let hash = '';\n        for (let y = 0; y < this.gameBoard.config.height; y++) {\n            for (let x = 0; x < this.gameBoard.config.width; x++) {\n                const block = this.gameBoard.getBlockAt(x, y);\n                hash += block ? block.blockType.charAt(0) : 'E';\n            }\n        }\n        return hash;\n    }\n    \n    /**\n     * [의도] 결과 캐싱 (메모리 관리 포함)\n     */\n    private cacheResult(hash: string, matches: Match[]): void {\n        // 캐시 크기 제한\n        if (this.matchCache.size >= this.MAX_CACHE_SIZE) {\n            const firstKey = this.matchCache.keys().next().value;\n            this.matchCache.delete(firstKey);\n        }\n        \n        this.matchCache.set(hash, matches);\n    }\n    \n    /**\n     * [의도] 캐시 초기화\n     */\n    public clearCache(): void {\n        this.matchCache.clear();\n        this.lastBoardHash = '';\n        console.log('[MatchDetector] 캐시 초기화 완료');\n    }\n    \n    /**\n     * [의도] 디버깅용 매치 정보 출력\n     */\n    public debugPrintMatches(matches: Match[]): void {\n        console.log(`[MatchDetector] 발견된 매치: ${matches.length}개`);\n        matches.forEach((match, index) => {\n            console.log(`  ${index + 1}. ${match.toString()}`);\n            console.log(`     위치: ${match.getPositions().map(p => `(${p.x},${p.y})`).join(', ')}`);\n        });\n    }\n}