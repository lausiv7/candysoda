/**
 * [의도] Sweet Puzzle 게임의 플레이어 진행 상황을 안전하게 추적하고 저장
 * [책임] 플레이어 데이터 영속화, 백업/복구, 데이터 검증, 클라우드 동기화
 */

import { _decorator, Component, sys } from 'cc';
import { PlayerProgress, WorldProgress, PlayerPreferences } from './ProgressionManager';

const { ccclass } = _decorator;

// 저장 타입
export enum SaveType {
    LOCAL_STORAGE = 'local_storage',
    CLOUD_SAVE = 'cloud_save',
    AUTO_BACKUP = 'auto_backup'
}

// 데이터 검증 결과
export interface ValidationResult {
    isValid: boolean;
    errors: string[];
    warnings: string[];
    fixedIssues: string[];
}

// 백업 정보
export interface BackupInfo {
    backupId: string;
    timestamp: number;
    dataVersion: string;
    playerLevel: number;
    totalStars: number;
    saveType: SaveType;
    dataSize: number;
}

// 동기화 상태
export enum SyncStatus {
    NOT_SYNCED = 'not_synced',
    SYNCING = 'syncing',
    SYNCED = 'synced',
    SYNC_FAILED = 'sync_failed',
    CONFLICT = 'conflict'
}

@ccclass('PlayerProgressTracker')
export class PlayerProgressTracker extends Component {
    
    private readonly STORAGE_KEY = 'sweet_puzzle_progress';
    private readonly BACKUP_KEY_PREFIX = 'sweet_puzzle_backup_';
    private readonly MAX_BACKUPS = 5;
    private readonly DATA_VERSION = '1.0.0';
    
    private currentProgress: PlayerProgress | null = null;
    private lastSaveTime: number = 0;
    private autoSaveInterval: number = 30000; // 30초
    private isDirty: boolean = false;
    private syncStatus: SyncStatus = SyncStatus.NOT_SYNCED;
    
    // 자동 저장 타이머
    private autoSaveTimer: number = 0;
    
    /**
     * [의도] 플레이어 진행 추적기 초기화
     */
    public initialize(): void {
        this.loadProgress();
        this.startAutoSave();
        
        console.log('[PlayerProgressTracker] 초기화 완료');
    }
    
    /**
     * [의도] 플레이어 진행 데이터 로드
     */
    public loadProgress(): PlayerProgress | null {
        try {\n            // 로컬 스토리지에서 데이터 로드\n            const savedData = sys.localStorage.getItem(this.STORAGE_KEY);\n            \n            if (!savedData) {\n                console.log('[PlayerProgressTracker] 저장된 데이터 없음, 새 플레이어 생성');\n                this.currentProgress = this.createNewPlayerProgress();\n                this.saveProgress(SaveType.LOCAL_STORAGE);\n                return this.currentProgress;\n            }\n            \n            const parsedData = JSON.parse(savedData);\n            \n            // 데이터 검증\n            const validation = this.validatePlayerData(parsedData);\n            if (!validation.isValid) {\n                console.error('[PlayerProgressTracker] 데이터 검증 실패:', validation.errors);\n                \n                // 백업에서 복구 시도\n                const recoveredData = this.recoverFromBackup();\n                if (recoveredData) {\n                    this.currentProgress = recoveredData;\n                    return this.currentProgress;\n                }\n                \n                // 복구 실패 시 새 데이터 생성\n                console.warn('[PlayerProgressTracker] 백업 복구 실패, 새 데이터 생성');\n                this.currentProgress = this.createNewPlayerProgress();\n                return this.currentProgress;\n            }\n            \n            // 데이터 구조 업그레이드 (필요시)\n            this.currentProgress = this.upgradeDataStructure(parsedData);\n            \n            // 수정사항이 있으면 저장\n            if (validation.fixedIssues.length > 0) {\n                this.saveProgress(SaveType.LOCAL_STORAGE);\n            }\n            \n            console.log('[PlayerProgressTracker] 플레이어 데이터 로드 완료');\n            return this.currentProgress;\n            \n        } catch (error) {\n            console.error('[PlayerProgressTracker] 데이터 로드 오류:', error);\n            \n            // 오류 발생 시 백업에서 복구\n            const recoveredData = this.recoverFromBackup();\n            if (recoveredData) {\n                this.currentProgress = recoveredData;\n                return this.currentProgress;\n            }\n            \n            // 최종적으로 새 데이터 생성\n            this.currentProgress = this.createNewPlayerProgress();\n            return this.currentProgress;\n        }\n    }\n    \n    /**\n     * [의도] 새 플레이어 진행 데이터 생성\n     */\n    private createNewPlayerProgress(): PlayerProgress {\n        const playerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n        \n        return {\n            playerId: playerId,\n            playerName: 'Sweet Player',\n            level: 1,\n            experience: 0,\n            coins: 1000,\n            gems: 10,\n            currentWorld: 'world_1',\n            currentLevel: 1,\n            totalStars: 0,\n            totalScore: 0,\n            totalPlayTime: 0,\n            gamesPlayed: 0,\n            averageStars: 0,\n            worldProgress: new Map<string, WorldProgress>(),\n            lastPlayedAt: Date.now(),\n            lastCompletedLevel: '',\n            preferences: {\n                soundEnabled: true,\n                musicEnabled: true,\n                vibrationEnabled: true,\n                language: 'ko',\n                difficulty: 'normal'\n            }\n        };\n    }\n    \n    /**\n     * [의도] 플레이어 데이터 검증\n     */\n    private validatePlayerData(data: any): ValidationResult {\n        const result: ValidationResult = {\n            isValid: true,\n            errors: [],\n            warnings: [],\n            fixedIssues: []\n        };\n        \n        // 필수 필드 확인\n        const requiredFields = ['playerId', 'playerName', 'level', 'coins', 'gems'];\n        for (const field of requiredFields) {\n            if (data[field] === undefined || data[field] === null) {\n                result.errors.push(`필수 필드 누락: ${field}`);\n                result.isValid = false;\n            }\n        }\n        \n        // 데이터 타입 검증\n        if (typeof data.level !== 'number' || data.level < 1) {\n            result.errors.push('잘못된 플레이어 레벨');\n            result.isValid = false;\n        }\n        \n        if (typeof data.coins !== 'number' || data.coins < 0) {\n            result.warnings.push('음수 코인 감지, 0으로 수정');\n            data.coins = Math.max(0, data.coins || 0);\n            result.fixedIssues.push('코인 값 수정');\n        }\n        \n        if (typeof data.gems !== 'number' || data.gems < 0) {\n            result.warnings.push('음수 젬 감지, 0으로 수정');\n            data.gems = Math.max(0, data.gems || 0);\n            result.fixedIssues.push('젬 값 수정');\n        }\n        \n        // 월드 진행 데이터 검증\n        if (!data.worldProgress) {\n            data.worldProgress = new Map();\n            result.fixedIssues.push('월드 진행 데이터 초기화');\n        }\n        \n        // 설정 검증\n        if (!data.preferences) {\n            data.preferences = {\n                soundEnabled: true,\n                musicEnabled: true,\n                vibrationEnabled: true,\n                language: 'ko',\n                difficulty: 'normal'\n            };\n            result.fixedIssues.push('설정 데이터 초기화');\n        }\n        \n        return result;\n    }\n    \n    /**\n     * [의도] 데이터 구조 업그레이드\n     */\n    private upgradeDataStructure(data: any): PlayerProgress {\n        // 버전별 데이터 구조 업그레이드 로직\n        // 현재는 1.0.0이므로 변환 없이 반환\n        \n        // Map 객체 복원 (JSON.parse는 Map을 일반 객체로 변환)\n        if (data.worldProgress && !(data.worldProgress instanceof Map)) {\n            const worldProgressMap = new Map<string, WorldProgress>();\n            if (Array.isArray(data.worldProgress)) {\n                // Array 형태로 저장된 경우\n                for (const [key, value] of data.worldProgress) {\n                    worldProgressMap.set(key, value as WorldProgress);\n                }\n            } else {\n                // Object 형태로 저장된 경우\n                for (const [key, value] of Object.entries(data.worldProgress)) {\n                    worldProgressMap.set(key, value as WorldProgress);\n                }\n            }\n            data.worldProgress = worldProgressMap;\n        }\n        \n        return data as PlayerProgress;\n    }\n    \n    /**\n     * [의도] 플레이어 진행 데이터 저장\n     */\n    public saveProgress(saveType: SaveType = SaveType.LOCAL_STORAGE): boolean {\n        if (!this.currentProgress) {\n            console.error('[PlayerProgressTracker] 저장할 데이터가 없음');\n            return false;\n        }\n        \n        try {\n            // Map을 Array로 변환하여 JSON 직렬화 가능하게 만듦\n            const serializableData = {\n                ...this.currentProgress,\n                worldProgress: Array.from(this.currentProgress.worldProgress.entries()),\n                dataVersion: this.DATA_VERSION,\n                savedAt: Date.now(),\n                saveType: saveType\n            };\n            \n            const dataString = JSON.stringify(serializableData);\n            \n            switch (saveType) {\n                case SaveType.LOCAL_STORAGE:\n                    sys.localStorage.setItem(this.STORAGE_KEY, dataString);\n                    break;\n                    \n                case SaveType.AUTO_BACKUP:\n                    this.createBackup(dataString);\n                    break;\n                    \n                case SaveType.CLOUD_SAVE:\n                    // TODO: 클라우드 저장 구현\n                    console.log('[PlayerProgressTracker] 클라우드 저장 (미구현)');\n                    break;\n            }\n            \n            this.lastSaveTime = Date.now();\n            this.isDirty = false;\n            \n            console.log(`[PlayerProgressTracker] 데이터 저장 완료 (${saveType})`);\n            return true;\n            \n        } catch (error) {\n            console.error('[PlayerProgressTracker] 저장 오류:', error);\n            return false;\n        }\n    }\n    \n    /**\n     * [의도] 백업 생성\n     */\n    private createBackup(dataString: string): void {\n        const backupId = 'backup_' + Date.now();\n        const backupKey = this.BACKUP_KEY_PREFIX + backupId;\n        \n        try {\n            sys.localStorage.setItem(backupKey, dataString);\n            \n            // 백업 정보 저장\n            const backupInfo: BackupInfo = {\n                backupId: backupId,\n                timestamp: Date.now(),\n                dataVersion: this.DATA_VERSION,\n                playerLevel: this.currentProgress?.level || 0,\n                totalStars: this.currentProgress?.totalStars || 0,\n                saveType: SaveType.AUTO_BACKUP,\n                dataSize: dataString.length\n            };\n            \n            this.saveBackupInfo(backupInfo);\n            this.cleanupOldBackups();\n            \n            console.log(`[PlayerProgressTracker] 백업 생성: ${backupId}`);\n            \n        } catch (error) {\n            console.error('[PlayerProgressTracker] 백업 생성 실패:', error);\n        }\n    }\n    \n    /**\n     * [의도] 백업 정보 저장\n     */\n    private saveBackupInfo(backupInfo: BackupInfo): void {\n        const backupListKey = 'sweet_puzzle_backup_list';\n        \n        try {\n            const existingListData = sys.localStorage.getItem(backupListKey);\n            let backupList: BackupInfo[] = [];\n            \n            if (existingListData) {\n                backupList = JSON.parse(existingListData);\n            }\n            \n            backupList.push(backupInfo);\n            backupList.sort((a, b) => b.timestamp - a.timestamp); // 최신순 정렬\n            \n            sys.localStorage.setItem(backupListKey, JSON.stringify(backupList));\n            \n        } catch (error) {\n            console.error('[PlayerProgressTracker] 백업 정보 저장 실패:', error);\n        }\n    }\n    \n    /**\n     * [의도] 백업에서 복구\n     */\n    private recoverFromBackup(): PlayerProgress | null {\n        const backupListKey = 'sweet_puzzle_backup_list';\n        \n        try {\n            const backupListData = sys.localStorage.getItem(backupListKey);\n            if (!backupListData) {\n                console.log('[PlayerProgressTracker] 백업 목록 없음');\n                return null;\n            }\n            \n            const backupList: BackupInfo[] = JSON.parse(backupListData);\n            \n            // 가장 최근 백업부터 복구 시도\n            for (const backupInfo of backupList) {\n                const backupKey = this.BACKUP_KEY_PREFIX + backupInfo.backupId;\n                const backupData = sys.localStorage.getItem(backupKey);\n                \n                if (backupData) {\n                    const parsedData = JSON.parse(backupData);\n                    const validation = this.validatePlayerData(parsedData);\n                    \n                    if (validation.isValid) {\n                        console.log(`[PlayerProgressTracker] 백업에서 복구: ${backupInfo.backupId}`);\n                        return this.upgradeDataStructure(parsedData);\n                    }\n                }\n            }\n            \n            console.log('[PlayerProgressTracker] 유효한 백업을 찾을 수 없음');\n            return null;\n            \n        } catch (error) {\n            console.error('[PlayerProgressTracker] 백업 복구 오류:', error);\n            return null;\n        }\n    }\n    \n    /**\n     * [의도] 오래된 백업 정리\n     */\n    private cleanupOldBackups(): void {\n        const backupListKey = 'sweet_puzzle_backup_list';\n        \n        try {\n            const backupListData = sys.localStorage.getItem(backupListKey);\n            if (!backupListData) return;\n            \n            const backupList: BackupInfo[] = JSON.parse(backupListData);\n            \n            if (backupList.length > this.MAX_BACKUPS) {\n                // 오래된 백업 삭제\n                const backupsToDelete = backupList.slice(this.MAX_BACKUPS);\n                \n                for (const backup of backupsToDelete) {\n                    const backupKey = this.BACKUP_KEY_PREFIX + backup.backupId;\n                    sys.localStorage.removeItem(backupKey);\n                }\n                \n                // 백업 목록 업데이트\n                const updatedList = backupList.slice(0, this.MAX_BACKUPS);\n                sys.localStorage.setItem(backupListKey, JSON.stringify(updatedList));\n                \n                console.log(`[PlayerProgressTracker] ${backupsToDelete.length}개 오래된 백업 삭제`);\n            }\n            \n        } catch (error) {\n            console.error('[PlayerProgressTracker] 백업 정리 오류:', error);\n        }\n    }\n    \n    /**\n     * [의도] 자동 저장 시작\n     */\n    private startAutoSave(): void {\n        this.autoSaveTimer = setInterval(() => {\n            if (this.isDirty && this.currentProgress) {\n                this.saveProgress(SaveType.AUTO_BACKUP);\n            }\n        }, this.autoSaveInterval) as any;\n        \n        console.log(`[PlayerProgressTracker] 자동 저장 시작 (${this.autoSaveInterval}ms 간격)`);\n    }\n    \n    /**\n     * [의도] 자동 저장 중지\n     */\n    private stopAutoSave(): void {\n        if (this.autoSaveTimer) {\n            clearInterval(this.autoSaveTimer);\n            this.autoSaveTimer = 0;\n        }\n    }\n    \n    /**\n     * [의도] 데이터 변경 알림\n     */\n    public markDirty(): void {\n        this.isDirty = true;\n    }\n    \n    /**\n     * [의도] 현재 플레이어 진행 데이터 조회\n     */\n    public getCurrentProgress(): PlayerProgress | null {\n        return this.currentProgress;\n    }\n    \n    /**\n     * [의도] 플레이어 진행 데이터 업데이트\n     */\n    public updateProgress(progress: PlayerProgress): void {\n        this.currentProgress = progress;\n        this.markDirty();\n    }\n    \n    /**\n     * [의도] 백업 목록 조회\n     */\n    public getBackupList(): BackupInfo[] {\n        const backupListKey = 'sweet_puzzle_backup_list';\n        \n        try {\n            const backupListData = sys.localStorage.getItem(backupListKey);\n            if (!backupListData) return [];\n            \n            return JSON.parse(backupListData) as BackupInfo[];\n            \n        } catch (error) {\n            console.error('[PlayerProgressTracker] 백업 목록 조회 오류:', error);\n            return [];\n        }\n    }\n    \n    /**\n     * [의도] 특정 백업으로 복구\n     */\n    public restoreFromBackup(backupId: string): boolean {\n        const backupKey = this.BACKUP_KEY_PREFIX + backupId;\n        \n        try {\n            const backupData = sys.localStorage.getItem(backupKey);\n            if (!backupData) {\n                console.error(`[PlayerProgressTracker] 백업을 찾을 수 없음: ${backupId}`);\n                return false;\n            }\n            \n            const parsedData = JSON.parse(backupData);\n            const validation = this.validatePlayerData(parsedData);\n            \n            if (!validation.isValid) {\n                console.error('[PlayerProgressTracker] 백업 데이터 검증 실패:', validation.errors);\n                return false;\n            }\n            \n            this.currentProgress = this.upgradeDataStructure(parsedData);\n            this.saveProgress(SaveType.LOCAL_STORAGE);\n            \n            console.log(`[PlayerProgressTracker] 백업에서 복구 완료: ${backupId}`);\n            return true;\n            \n        } catch (error) {\n            console.error('[PlayerProgressTracker] 백업 복구 오류:', error);\n            return false;\n        }\n    }\n    \n    /**\n     * [의도] 데이터 내보내기 (JSON 문자열)\n     */\n    public exportData(): string | null {\n        if (!this.currentProgress) {\n            console.error('[PlayerProgressTracker] 내보낼 데이터가 없음');\n            return null;\n        }\n        \n        try {\n            const exportData = {\n                ...this.currentProgress,\n                worldProgress: Array.from(this.currentProgress.worldProgress.entries()),\n                exportedAt: Date.now(),\n                exportVersion: this.DATA_VERSION\n            };\n            \n            return JSON.stringify(exportData, null, 2);\n            \n        } catch (error) {\n            console.error('[PlayerProgressTracker] 데이터 내보내기 오류:', error);\n            return null;\n        }\n    }\n    \n    /**\n     * [의도] 데이터 가져오기 (JSON 문자열에서)\n     */\n    public importData(dataString: string): boolean {\n        try {\n            const importedData = JSON.parse(dataString);\n            const validation = this.validatePlayerData(importedData);\n            \n            if (!validation.isValid) {\n                console.error('[PlayerProgressTracker] 가져온 데이터 검증 실패:', validation.errors);\n                return false;\n            }\n            \n            // 기존 데이터 백업\n            if (this.currentProgress) {\n                this.saveProgress(SaveType.AUTO_BACKUP);\n            }\n            \n            this.currentProgress = this.upgradeDataStructure(importedData);\n            this.saveProgress(SaveType.LOCAL_STORAGE);\n            \n            console.log('[PlayerProgressTracker] 데이터 가져오기 완료');\n            return true;\n            \n        } catch (error) {\n            console.error('[PlayerProgressTracker] 데이터 가져오기 오류:', error);\n            return false;\n        }\n    }\n    \n    /**\n     * [의도] 컴포넌트 정리\n     */\n    onDestroy(): void {\n        this.stopAutoSave();\n        \n        // 마지막 저장\n        if (this.isDirty && this.currentProgress) {\n            this.saveProgress(SaveType.LOCAL_STORAGE);\n        }\n        \n        console.log('[PlayerProgressTracker] 정리 완료');\n    }\n}