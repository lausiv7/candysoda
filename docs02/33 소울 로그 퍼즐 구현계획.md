# 33. Sweet Puzzle 소울라이크 로그라이크 구현계획

## 📋 개요

32번 설계 문서 + **99번 BM_LevelDesign.md**를 바탕으로 기존 Sweet Puzzle 코드베이스를 **데이터 기반 자동 밸런싱 소울라이크 로그라이크** 게임으로 전환하는 구체적인 구현 계획서입니다.

### 🎯 구현 전략 (99번 문서 기반)

**기존 코드 최대 활용** + **99번 데이터 기반 튜닝** + **점진적 기능 추가** 방식으로 리스크를 최소화하면서 **공정한 성장 경험**을 제공하는 혁신적인 게임플레이를 구현합니다.

## 🏗️ Phase 1: 로그라이크 핵심 시스템 구현 (4-6주)

### 1.1 RunManager 시스템 구현

#### 1.1.1 새로운 파일 생성
```typescript
// src/managers/RunManager.ts
import { GameBoard } from '../puzzle/GameBoard';
import { StageConfig, RunResult, Rune } from '../types/SoulLikeTypes';

export class RunManager {
    private currentStage: number = 1;
    private selectedRunes: Rune[] = [];
    private runStartPower: number;
    private stageConfigs: StageConfig[];

    constructor() {
        this.initializeStageConfigs();
    }

    // 99번 문서 구간별 난이도 + 31번 문서 공식 통합
    private calculateStageRequirement(stage: number): number {
        // 99번 문서 구간별 설정
        const stageBracket = this.getStageBracket(stage);
        const baseReq = stageBracket.base_requirement;
        const growthRate = stageBracket.growth_rate;
        
        const stageInBracket = stage - stageBracket.start_stage + 1;
        return Math.floor(baseReq * Math.pow(growthRate, stageInBracket - 1));
    }
    
    private getStageBracket(stage: number): StageBracket {
        if (stage <= 5) return {base_requirement: 100, growth_rate: 1.05, start_stage: 1};
        if (stage <= 20) return {base_requirement: 120, growth_rate: 1.08, start_stage: 6};
        if (stage <= 40) return {base_requirement: 180, growth_rate: 1.12, start_stage: 21};
        return {base_requirement: 300, growth_rate: 1.15, start_stage: 41};
    }

    async startRun(playerPower: number): Promise<void> {
        // 에너지 차감 (기존 코드 활용)
        await EnergyManager.consumeEnergy(1);
        
        this.runStartPower = playerPower;
        this.selectedRunes = [];
        
        for (let stage = 1; stage <= 5; stage++) {
            const stageResult = await this.executeStage(stage);
            
            if (!stageResult.success) {
                return this.handleRunFailure(stage, stageResult);
            }
            
            // 룬 선택 (보스 스테이지 제외)
            if (stage < 5) {
                const selectedRune = await this.presentRuneChoice(stage);
                this.selectedRunes.push(selectedRune);
                this.applyRuneToNextStage(selectedRune);
            }
        }
        
        return this.completeRun();
    }
}
```

#### 1.1.2 기존 GameBoard.ts 확장
```typescript
// 기존 GameBoard.ts에 추가할 메서드들
export class GameBoard {
    // 새로 추가되는 속성들
    public activeRunes: Rune[] = [];
    public stageMultiplier: number = 1.0;
    public timeBonus: number = 0;
    
    // 룬 효과 적용 메서드 추가
    public applyRuneEffects(): void {
        for (const rune of this.activeRunes) {
            switch (rune.type) {
                case 'TIME_EXTENSION':
                    this.timeLimit += rune.value;
                    break;
                case 'SPECIAL_BLOCK_BOOST':
                    this.specialBlockGenerationRate *= (1 + rune.value);
                    break;
                case 'COMBO_MASTER':
                    this.comboMultiplier *= (1 + rune.value);
                    break;
                case 'POWER_START':
                    this.generateInitialSpecialBlocks(rune.value);
                    break;
            }
        }
    }
    
    // 기존 startLevel 메서드 확장
    public startLevel(levelConfig: any): void {
        // 기존 로직 실행
        super.startLevel(levelConfig);
        
        // 룬 효과 적용
        this.applyRuneEffects();
        
        // 소울라이크 스테이지 난이도 적용
        this.applyStageModifiers();
    }
}
```

### 1.2 룬 시스템 구현

#### 1.2.1 룬 데이터 모델
```typescript
// src/types/RuneTypes.ts
export enum RuneType {
    TIME_EXTENSION = 'TIME_EXTENSION',
    SPECIAL_BLOCK_BOOST = 'SPECIAL_BLOCK_BOOST', 
    COMBO_MASTER = 'COMBO_MASTER',
    POWER_START = 'POWER_START',
    SCORE_MULTIPLIER = 'SCORE_MULTIPLIER',
    MOVE_BONUS = 'MOVE_BONUS'
}

export enum RuneRarity {
    COMMON = 'COMMON',
    RARE = 'RARE', 
    EPIC = 'EPIC',
    LEGENDARY = 'LEGENDARY'
}

export interface Rune {
    id: string;
    type: RuneType;
    rarity: RuneRarity;
    name: string;
    description: string;
    value: number;
    icon: string;
    flavorText: string;
}

// 룬 데이터베이스
export const RUNE_DATABASE: Record<RuneType, Rune[]> = {
    [RuneType.TIME_EXTENSION]: [
        {
            id: 'time_common',
            type: RuneType.TIME_EXTENSION,
            rarity: RuneRarity.COMMON,
            name: '시간의 조각',
            description: '제한시간 +15초',
            value: 15,
            icon: '⏳',
            flavorText: '시간은 가장 소중한 자원이다.'
        },
        {
            id: 'time_rare',
            type: RuneType.TIME_EXTENSION,
            rarity: RuneRarity.RARE,
            name: '시간의 흐름',
            description: '제한시간 +25초',
            value: 25,
            icon: '⏰',
            flavorText: '시간을 다스리는 자가 승리한다.'
        }
    ],
    // ... 다른 룬 타입들
};
```

#### 1.2.2 룬 선택 UI 컴포넌트
```typescript
// src/ui/RuneSelectionUI.ts
export class RuneSelectionUI {
    private selectionContainer: HTMLElement;
    private onRuneSelected: (rune: Rune) => void;
    
    constructor(onRuneSelected: (rune: Rune) => void) {
        this.onRuneSelected = onRuneSelected;
        this.createSelectionUI();
    }
    
    public showRuneChoices(runes: Rune[], canReroll: boolean = true): Promise<Rune> {
        return new Promise((resolve) => {
            this.renderRuneOptions(runes);
            
            if (canReroll) {
                this.addRerollButton(() => {
                    // 300코인으로 재선택 (BM 포인트)
                    this.showPaymentModal('rune_reroll', 300);
                });
            }
            
            this.onRuneSelected = resolve;
            this.show();
        });
    }
    
    private renderRuneOptions(runes: Rune[]): void {
        const runeContainer = this.selectionContainer.querySelector('.rune-options');
        runeContainer.innerHTML = '';
        
        runes.forEach((rune, index) => {
            const runeCard = this.createRuneCard(rune, index);
            runeContainer.appendChild(runeCard);
        });
    }
    
    private createRuneCard(rune: Rune, index: number): HTMLElement {
        const card = document.createElement('div');
        card.className = `rune-card rarity-${rune.rarity.toLowerCase()}`;
        
        card.innerHTML = `
            <div class="rune-icon">${rune.icon}</div>
            <div class="rune-name">${rune.name}</div>
            <div class="rune-description">${rune.description}</div>
            <div class="rune-rarity">${rune.rarity}</div>
            <div class="rune-flavor">${rune.flavorText}</div>
        `;
        
        card.addEventListener('click', () => {
            this.selectRune(rune);
        });
        
        // 애니메이션 효과
        card.style.animationDelay = `${index * 0.2}s`;
        card.classList.add('rune-appear');
        
        return card;
    }
}
```

### 1.3 장비 시스템 기초 구현

#### 1.3.1 장비 데이터 모델
```typescript
// src/types/EquipmentTypes.ts
export enum EquipmentSlot {
    WEAPON = 'WEAPON',
    ARMOR = 'ARMOR', 
    ACCESSORY = 'ACCESSORY'
}

export interface Equipment {
    id: string;
    slot: EquipmentSlot;
    name: string;
    rarity: RuneRarity;
    level: number;
    maxLevel: number;
    basePower: number;
    effects: EquipmentEffect[];
    upgradeRequirements: UpgradeRequirement[];
}

export interface EquipmentEffect {
    type: 'POWER' | 'SPECIAL_RATE' | 'TIME_BONUS' | 'SCORE_MULT' | 'ENERGY_SAVE';
    value: number;
    description: string;
}

// 장비 데이터베이스
export const EQUIPMENT_DATABASE: Equipment[] = [
    {
        id: 'weapon_001',
        slot: EquipmentSlot.WEAPON,
        name: '마법 지팡이',
        rarity: RuneRarity.COMMON,
        level: 1,
        maxLevel: 10,
        basePower: 25,
        effects: [
            {
                type: 'SPECIAL_RATE',
                value: 0.05,
                description: '특수블록 생성률 +5%'
            }
        ],
        upgradeRequirements: [
            { resource: 'COINS', amount: 1000 },
            { resource: 'GEMS', amount: 10 }
        ]
    }
    // ... 더 많은 장비들
];
```

#### 1.3.2 EquipmentManager 구현
```typescript
// src/managers/EquipmentManager.ts
export class EquipmentManager {
    private equippedItems: Map<EquipmentSlot, Equipment> = new Map();
    private inventory: Equipment[] = [];
    
    public calculateTotalPower(): number {
        let totalPower = 100; // 기본 전투력
        
        this.equippedItems.forEach((equipment) => {
            totalPower += this.calculateEquipmentPower(equipment);
        });
        
        return totalPower;
    }
    
    private calculateEquipmentPower(equipment: Equipment): number {
        const levelMultiplier = 1 + (equipment.level - 1) * 0.1;
        const rarityMultiplier = this.getRarityMultiplier(equipment.rarity);
        
        return equipment.basePower * levelMultiplier * rarityMultiplier;
    }
    
    public upgradeEquipment(equipmentId: string): Promise<boolean> {
        const equipment = this.findEquipmentById(equipmentId);
        if (!equipment || equipment.level >= equipment.maxLevel) {
            return Promise.resolve(false);
        }
        
        // 업그레이드 비용 계산 (31번 문서 공식)
        const upgradeCost = this.calculateUpgradeCost(equipment);
        
        return PaymentManager.spendResources(upgradeCost)
            .then(() => {
                equipment.level++;
                this.saveEquipmentData();
                return true;
            });
    }
}
```

### 1.4 에너지(번개) 시스템 구현

#### 1.4.1 EnergyManager 확장
```typescript
// 기존 EnergyManager를 확장하여 소울라이크 특화 기능 추가
export class EnergyManager {
    private static readonly MAX_ENERGY = 5;
    private static readonly RECHARGE_INTERVAL = 25 * 60 * 1000; // 25분
    
    // 기존 메서드들...
    
    // 새로 추가되는 메서드들
    public static async consumeEnergyForRun(): Promise<boolean> {
        const currentEnergy = await this.getCurrentEnergy();
        
        if (currentEnergy <= 0) {
            // 에너지 부족 시 구매 제안 (BM 포인트)
            const purchaseOffered = await this.offerEnergyPurchase();
            return purchaseOffered;
        }
        
        await this.setCurrentEnergy(currentEnergy - 1);
        await this.updateLastUsedTime();
        
        return true;
    }
    
    private static async offerEnergyPurchase(): Promise<boolean> {
        // 31번 문서의 구매 동기 분석 적용
        const player = await PlayerManager.getCurrentPlayer();
        const purchaseProbability = PurchaseManager.calculatePurchaseProbability(player);
        
        if (purchaseProbability > 0.15) {
            return await this.showEnergyPurchaseModal();
        }
        
        return false;
    }
    
    private static async showEnergyPurchaseModal(): Promise<boolean> {
        const modal = new PurchaseModal({
            title: '에너지 부족!',
            description: '런을 계속하려면 번개가 필요합니다.',
            offers: [
                {
                    id: 'energy_5',
                    name: '번개 5개',
                    price: '$0.99',
                    coins: 1000,
                    popular: true
                },
                {
                    id: 'energy_unlimited_1h',
                    name: '무제한 1시간',
                    price: '$2.99',
                    coins: 3000,
                    bestValue: true
                }
            ]
        });
        
        return await modal.show();
    }
}
```

## 🏗️ Phase 2: 공정한 BM 시스템 구현 (4주) - 99-01번 문서 윤리적 수익화 전략

### 2.1 가챠 시스템 구현

#### 2.1.1 GachaManager 생성
```typescript
// src/managers/GachaManager.ts
export class GachaManager {
    private static readonly GACHA_RATES = {
        [RuneRarity.COMMON]: 0.60,
        [RuneRarity.RARE]: 0.25,
        [RuneRarity.EPIC]: 0.12,
        [RuneRarity.LEGENDARY]: 0.03
    };
    
    private static readonly PITY_THRESHOLD = 50;
    
    public static async performSinglePull(playerId: string): Promise<Equipment> {
        // 비용 차감
        await PaymentManager.spendCoins(playerId, 500);
        
        // 천장 시스템 확인
        const pityCount = await this.getPityCount(playerId);
        let guaranteedRarity: RuneRarity | null = null;
        
        if (pityCount >= this.PITY_THRESHOLD) {
            guaranteedRarity = RuneRarity.EPIC;
            await this.resetPityCount(playerId);
        }
        
        // 확률에 따른 장비 추첨
        const rarity = guaranteedRarity || this.rollRarity();
        const equipment = this.selectRandomEquipment(rarity);
        
        // 인벤토리에 추가
        await InventoryManager.addEquipment(playerId, equipment);
        
        // 천장 카운터 증가
        if (!guaranteedRarity) {
            await this.incrementPityCount(playerId);
        }
        
        // 애널리틱스 이벤트
        AnalyticsManager.trackGachaPull(playerId, equipment.rarity, pityCount);
        
        return equipment;
    }
    
    public static async perform10Pull(playerId: string): Promise<Equipment[]> {
        // 10연차 할인 (4500코인 = 500x9)
        await PaymentManager.spendCoins(playerId, 4500);
        
        const results: Equipment[] = [];
        
        for (let i = 0; i < 10; i++) {
            // 마지막 뽑기는 레어 이상 보장
            const guaranteedRare = i === 9;
            const equipment = await this.performSinglePullInternal(playerId, guaranteedRare);
            results.push(equipment);
        }
        
        return results;
    }
}
```

#### 2.1.2 가챠 UI 구현
```typescript
// src/ui/GachaUI.ts
export class GachaUI {
    public showGachaResults(equipments: Equipment[]): Promise<void> {
        return new Promise((resolve) => {
            // 화려한 뽑기 애니메이션
            this.playGachaAnimation(equipments).then(() => {
                // 결과 표시
                this.displayResults(equipments);
                
                // 추가 뽑기 유도 (BM)
                if (equipments.some(e => e.rarity === RuneRarity.LEGENDARY)) {
                    this.showCongratuationsModal();
                } else {
                    this.showContinuePullingSuggestion();
                }
                
                resolve();
            });
        });
    }
    
    private async playGachaAnimation(equipments: Equipment[]): Promise<void> {
        // 궁수의 전설 스타일 화려한 애니메이션
        const container = document.getElementById('gacha-animation');
        
        for (let i = 0; i < equipments.length; i++) {
            const equipment = equipments[i];
            
            // 수정구 깨지는 효과
            await this.playCrystalBreakAnimation();
            
            // 장비 등장 애니메이션 
            await this.playEquipmentRevealAnimation(equipment);
            
            // 레어도별 특수 효과
            if (equipment.rarity === RuneRarity.LEGENDARY) {
                await this.playLegendaryEffect();
                AudioManager.playSound('legendary_pull');
            }
            
            await this.delay(500); // 간격
        }
    }
}
```

### 2.2 구매 동기 분석 시스템

#### 2.2.1 PurchaseAnalytics 구현
```typescript
// src/analytics/PurchaseAnalytics.ts
export class PurchaseAnalytics {
    // 31번 문서의 로지스틱 회귀 모델 구현
    public static calculatePurchaseProbability(player: Player): number {
        // 특성 추출
        const pf = this.calculateProgressFriction(player);
        const ls = Math.min(player.lossStreak, 10); // 상한 설정
        const rs = this.calculateResourceScarcity(player);
        const rm = this.getCurrentRewardMagnitude(player);
        const pvs = this.getPlayerValueSegment(player);
        const recent_success = Math.max(0, player.recentSuccessCount - 2);
        
        // 31번 문서 공식 적용
        const b0 = -3.0, b1 = 2.0, b2 = 0.5, b3 = 1.5, b4 = 1.0, b5 = 2.5, b6 = -1.0;
        
        const logit = b0 + b1*pf + b2*ls + b3*rs + b4*rm + b5*pvs + b6*recent_success;
        
        return 1 / (1 + Math.exp(-logit));
    }
    
    private static calculateProgressFriction(player: Player): number {
        const effectivePower = player.totalPower * 0.6 + player.skillRating * 0.4;
        const currentStageRequirement = RunManager.getCurrentStageRequirement();
        
        const gap = effectivePower / currentStageRequirement;
        return Math.max(0, 1 - gap); // Gap < 1일 때만 좌절감 발생
    }
    
    private static calculateResourceScarcity(player: Player): number {
        const energyShortageDuration = Date.now() - player.lastEnergyFullTime;
        const hoursWithoutEnergy = energyShortageDuration / (1000 * 60 * 60);
        
        return Math.min(hoursWithoutEnergy / 2, 5); // 최대 5점
    }
}
```

#### 2.2.2 Dynamic Offer System
```typescript
// src/systems/DynamicOfferSystem.ts
export class DynamicOfferSystem {
    public static async evaluateAndShowOffer(player: Player): Promise<void> {
        const probability = PurchaseAnalytics.calculatePurchaseProbability(player);
        
        // 15% 이상일 때만 제안 표시
        if (probability < 0.15) return;
        
        const offerType = this.selectBestOfferType(player);
        const offer = await this.generatePersonalizedOffer(offerType, player);
        
        // 제안 표시
        await this.showOfferModal(offer, probability);
        
        // 분석 데이터 수집
        AnalyticsManager.trackOfferShown(player.id, offerType, probability);
    }
    
    private static selectBestOfferType(player: Player): OfferType {
        // 상황에 맞는 최적 제안 선택
        if (player.energyCount <= 0) {
            return OfferType.ENERGY_PACKAGE;
        } else if (player.lossStreak >= 3) {
            return OfferType.POWER_UP_PACKAGE;
        } else if (player.nearMilestone) {
            return OfferType.PREMIUM_GACHA;
        } else {
            return OfferType.STARTER_BUNDLE;
        }
    }
}
```

### 2.3 결제 시스템 통합

#### 2.3.1 PaymentManager 확장
```typescript
// src/managers/PaymentManager.ts  
export class PaymentManager {
    // Google Play Billing 연동
    public static async initializeBilling(): Promise<void> {
        if (PlatformManager.isAndroid()) {
            await this.initializeGooglePlayBilling();
        } else if (PlatformManager.isWeb()) {
            await this.initializeWebPayments();
        }
    }
    
    public static async purchaseProduct(productId: string): Promise<boolean> {
        try {
            // 결제 전 검증
            const isValidPurchase = await this.validatePurchaseRequest(productId);
            if (!isValidPurchase) return false;
            
            // 플랫폼별 결제 처리
            const purchaseResult = await this.processPlatformPayment(productId);
            
            if (purchaseResult.success) {
                // 아이템 지급
                await this.fulfillPurchase(purchaseResult.purchaseToken, productId);
                
                // 분석 데이터
                AnalyticsManager.trackPurchase(productId, purchaseResult.price);
                
                return true;
            }
            
            return false;
        } catch (error) {
            console.error('Purchase failed:', error);
            return false;
        }
    }
    
    private static async fulfillPurchase(purchaseToken: string, productId: string): Promise<void> {
        const productConfig = PRODUCT_CATALOG[productId];
        
        switch (productConfig.type) {
            case 'ENERGY':
                await EnergyManager.addEnergy(productConfig.amount);
                break;
            case 'COINS':
                await CurrencyManager.addCoins(productConfig.amount);
                break;
            case 'GACHA_TICKETS':
                await GachaManager.addTickets(productConfig.amount);
                break;
            case 'PREMIUM_BUNDLE':
                await this.fulfillPremiumBundle(productConfig);
                break;
        }
    }
}
```

## 🏗️ Phase 3: 밸런싱 및 최적화 (3-4주)

### 3.1 시뮬레이션 시스템 구현

#### 3.1.1 GameSimulator 구현 (31번 문서 기반)
```typescript
// src/simulation/GameSimulator.ts
export class GameSimulator {
    public static async runBalanceSimulation(config: SimulationConfig): Promise<SimulationResult> {
        const results: PlayerSimulationResult[] = [];
        
        // 플레이어 세그먼트별 시뮬레이션
        for (const segment of config.playerSegments) {
            const segmentResults = await this.simulatePlayerSegment(segment, config);
            results.push(...segmentResults);
        }
        
        return this.analyzeSimulationResults(results);
    }
    
    private static async simulatePlayerSegment(
        segment: PlayerSegment, 
        config: SimulationConfig
    ): Promise<PlayerSimulationResult[]> {
        const results: PlayerSimulationResult[] = [];
        
        for (let i = 0; i < segment.playerCount; i++) {
            // 31번 문서의 플레이어 모델링 적용
            const player = this.generateSimulatedPlayer(segment);
            const playerResult = await this.simulatePlayerJourney(player, config);
            results.push(playerResult);
        }
        
        return results;
    }
    
    private static generateSimulatedPlayer(segment: PlayerSegment): SimulatedPlayer {
        return {
            id: `sim_${Date.now()}_${Math.random()}`,
            power: this.sampleNormal(segment.powerMean, segment.powerStd),
            skill: this.sampleNormal(segment.skillMean, segment.skillStd),
            pvs: segment.pvs,
            lossStreak: 0,
            totalSpent: 0,
            sessionsPlayed: 0,
            runsCompleted: 0
        };
    }
    
    private static async simulatePlayerJourney(
        player: SimulatedPlayer, 
        config: SimulationConfig
    ): Promise<PlayerSimulationResult> {
        const journey: RunResult[] = [];
        
        // 30일간 시뮬레이션
        for (let day = 1; day <= 30; day++) {
            const dailyRuns = this.calculateDailyRuns(player, day);
            
            for (let run = 0; run < dailyRuns; run++) {
                const runResult = await this.simulateRun(player, config);
                journey.push(runResult);
                
                // 플레이어 상태 업데이트
                this.updatePlayerState(player, runResult);
                
                // 구매 결정
                if (!runResult.success) {
                    const purchaseDecision = await this.simulatePurchaseDecision(player);
                    if (purchaseDecision.purchased) {
                        player.totalSpent += purchaseDecision.amount;
                    }
                }
            }
        }
        
        return {
            playerId: player.id,
            segment: this.getPlayerSegmentName(player),
            totalRuns: journey.length,
            completedRuns: journey.filter(r => r.success).length,
            totalSpent: player.totalSpent,
            avgRunDuration: this.calculateAvgRunDuration(journey),
            retentionDays: this.calculateRetentionDays(journey)
        };
    }
}
```

#### 3.1.2 밸런싱 자동화 도구
```typescript
// src/tools/BalancingTool.ts
export class BalancingTool {
    public static async optimizeStageRequirements(): Promise<OptimizationResult> {
        const currentConfig = ConfigManager.getCurrentBalanceConfig();
        const targetMetrics = {
            avgCompletionRate: 0.45, // 45% 런 완주 목표
            f2pCompletionRate: 0.35, // F2P 35% 완주
            whaleCompletionRate: 0.70, // 고과금 70% 완주
            avgConversionRate: 0.15   // 15% 전환율
        };
        
        let bestConfig = currentConfig;
        let bestScore = await this.evaluateConfig(bestConfig, targetMetrics);
        
        // 유전 알고리즘 방식으로 최적화
        for (let generation = 0; generation < 50; generation++) {
            const candidates = this.generateConfigVariants(bestConfig);
            
            for (const candidate of candidates) {
                const score = await this.evaluateConfig(candidate, targetMetrics);
                if (score > bestScore) {
                    bestConfig = candidate;
                    bestScore = score;
                }
            }
            
            console.log(`Generation ${generation}: Best Score = ${bestScore}`);
        }
        
        return {
            optimizedConfig: bestConfig,
            improvementScore: bestScore,
            recommendedChanges: this.generateRecommendations(currentConfig, bestConfig)
        };
    }
    
    private static async evaluateConfig(
        config: BalanceConfig, 
        targets: TargetMetrics
    ): Promise<number> {
        // 빠른 시뮬레이션 실행 (1000명 플레이어)
        const simulationResult = await GameSimulator.runBalanceSimulation({
            playerSegments: this.getTestPlayerSegments(),
            stageConfigs: config.stageConfigs,
            runeEffects: config.runeEffects,
            maxSimulationDays: 7 // 빠른 테스트용
        });
        
        // 목표 대비 점수 계산
        const completionScore = this.scoreMetric(
            simulationResult.avgCompletionRate, 
            targets.avgCompletionRate
        );
        
        const conversionScore = this.scoreMetric(
            simulationResult.conversionRate,
            targets.avgConversionRate
        );
        
        const retentionScore = this.scoreMetric(
            simulationResult.d7Retention,
            0.20 // D7 20% 목표
        );
        
        return (completionScore + conversionScore + retentionScore) / 3;
    }
}
```

### 3.2 A/B 테스트 프레임워크

#### 3.2.1 ABTestManager 구현
```typescript
// src/ab-testing/ABTestManager.ts
export class ABTestManager {
    private static experiments: Map<string, ABExperiment> = new Map();
    
    public static async initializeExperiments(): Promise<void> {
        // 서버에서 실험 목록 가져오기
        const activeExperiments = await APIClient.getActiveExperiments();
        
        for (const experiment of activeExperiments) {
            this.experiments.set(experiment.id, experiment);
            
            // 플레이어를 실험 그룹에 할당
            await this.assignPlayerToExperiment(experiment);
        }
    }
    
    public static getVariant(experimentId: string): string | null {
        const experiment = this.experiments.get(experimentId);
        if (!experiment) return null;
        
        const playerId = PlayerManager.getCurrentPlayerId();
        return experiment.playerAssignments.get(playerId) || null;
    }
    
    // 사용 예시: 에너지 회복 속도 A/B 테스트
    public static getEnergyRechargeInterval(): number {
        const variant = this.getVariant('energy_recharge_test');
        
        switch (variant) {
            case 'control': return 25 * 60 * 1000; // 25분
            case 'treatment_a': return 20 * 60 * 1000; // 20분  
            case 'treatment_b': return 30 * 60 * 1000; // 30분
            default: return 25 * 60 * 1000; // 기본값
        }
    }
    
    // 룬 선택 개수 A/B 테스트
    public static getRuneChoiceCount(): number {
        const variant = this.getVariant('rune_choice_count');
        
        return variant === 'four_choices' ? 4 : 3;
    }
}
```

#### 3.2.2 실험 결과 분석
```typescript
// src/ab-testing/ExperimentAnalyzer.ts
export class ExperimentAnalyzer {
    public static async analyzeExperimentResults(experimentId: string): Promise<ExperimentResult> {
        const experiment = ABTestManager.getExperiment(experimentId);
        const playerData = await this.getExperimentPlayerData(experimentId);
        
        const results: VariantResult[] = [];
        
        for (const variant of experiment.variants) {
            const variantPlayers = playerData.filter(p => p.variant === variant.id);
            
            const metrics = {
                playerCount: variantPlayers.length,
                avgSessionLength: this.calculateAvgSessionLength(variantPlayers),
                conversionRate: this.calculateConversionRate(variantPlayers),
                d1Retention: this.calculateD1Retention(variantPlayers),
                d7Retention: this.calculateD7Retention(variantPlayers),
                arpu: this.calculateARPU(variantPlayers),
                runCompletionRate: this.calculateRunCompletionRate(variantPlayers)
            };
            
            results.push({
                variant: variant.id,
                metrics,
                significance: this.calculateStatisticalSignificance(metrics, experiment.control)
            });
        }
        
        return {
            experimentId,
            variants: results,
            recommendation: this.generateRecommendation(results),
            confidence: this.calculateConfidence(results)
        };
    }
}
```

## 🚀 Phase 4: 소프트 런칭 준비 (2-3주)

### 4.1 운영 대시보드 구현

#### 4.1.1 LiveOpsManager
```typescript
// src/liveops/LiveOpsManager.ts
export class LiveOpsManager {
    public static async initializeLiveOps(): Promise<void> {
        // 실시간 설정 동기화
        await this.syncRemoteConfig();
        
        // 이벤트 시스템 초기화
        await EventManager.initialize();
        
        // KPI 추적 시작
        await this.startKPITracking();
    }
    
    public static async updateBalanceParameters(params: BalanceUpdate): Promise<void> {
        // 실시간 밸런싱 조정 (서버 재시작 없이)
        
        if (params.stageRequirements) {
            RunManager.updateStageRequirements(params.stageRequirements);
        }
        
        if (params.runeEffects) {
            RuneManager.updateRuneEffects(params.runeEffects);
        }
        
        if (params.gachaRates) {
            GachaManager.updateRates(params.gachaRates);
        }
        
        // 변경사항 로그
        AnalyticsManager.trackBalanceChange(params);
        
        // 플레이어에게 알림 (선택적)
        if (params.notifyPlayers) {
            NotificationManager.sendBalanceUpdateNotification();
        }
    }
    
    // 실시간 KPI 모니터링
    public static async getRealtimeKPIs(): Promise<RealtimeKPIs> {
        const now = new Date();
        const hour = 60 * 60 * 1000;
        
        return {
            timestamp: now,
            activeUsers: await UserManager.getActiveUserCount(now - hour),
            avgSessionLength: await AnalyticsManager.getAvgSessionLength(now - hour),
            runCompletionRate: await GameManager.getRunCompletionRate(now - hour),
            conversionEvents: await PaymentManager.getConversionEvents(now - hour),
            revenue: await PaymentManager.getHourlyRevenue(now - hour),
            energyPurchases: await PaymentManager.getEnergyPurchases(now - hour),
            gachaPulls: await GachaManager.getHourlyPulls(now - hour)
        };
    }
}
```

#### 4.1.2 알림 및 응급 대응 시스템
```typescript
// src/monitoring/AlertSystem.ts
export class AlertSystem {
    private static readonly ALERT_THRESHOLDS = {
        crashRate: 0.05,        // 5% 이상 크래시
        conversionDrop: 0.30,   // 전환율 30% 하락
        revenueDrop: 0.40,      // 매출 40% 하락
        retentionDrop: 0.25,    // 리텐션 25% 하락
        completionDrop: 0.20    // 완주율 20% 하락
    };
    
    public static async monitorKPIs(): Promise<void> {
        const currentKPIs = await LiveOpsManager.getRealtimeKPIs();
        const historicalKPIs = await this.getHistoricalBaseline();
        
        const alerts: Alert[] = [];
        
        // 각 지표별 임계치 검사
        if (this.isSignificantDrop(currentKPIs.conversionRate, historicalKPIs.conversionRate, this.ALERT_THRESHOLDS.conversionDrop)) {
            alerts.push({
                severity: 'HIGH',
                metric: 'conversion_rate',
                message: `전환율 급락 감지: ${currentKPIs.conversionRate}% (기준: ${historicalKPIs.conversionRate}%)`,
                suggestedAction: 'A/B 테스트 확인, 결제 시스템 점검'
            });
        }
        
        if (this.isSignificantDrop(currentKPIs.runCompletionRate, historicalKPIs.runCompletionRate, this.ALERT_THRESHOLDS.completionDrop)) {
            alerts.push({
                severity: 'MEDIUM',
                metric: 'run_completion_rate', 
                message: `런 완주율 하락: ${currentKPIs.runCompletionRate}%`,
                suggestedAction: '난이도 밸런싱 검토, 긴급 버프 이벤트 고려'
            });
        }
        
        // 알림 발송
        if (alerts.length > 0) {
            await this.sendAlertsToOperators(alerts);
            
            // 자동 대응 (설정된 경우)
            await this.executeAutomaticResponse(alerts);
        }
    }
    
    private static async executeAutomaticResponse(alerts: Alert[]): Promise<void> {
        for (const alert of alerts) {
            switch (alert.metric) {
                case 'run_completion_rate':
                    // 자동으로 모든 플레이어에게 버프 이벤트 활성화
                    await EventManager.activateEmergencyEvent('global_power_boost');
                    break;
                    
                case 'conversion_rate':
                    // 할인 이벤트 자동 활성화
                    await EventManager.activateEmergencyEvent('flash_sale');
                    break;
            }
        }
    }
}
```

### 4.2 데이터 수집 및 분석 시스템

#### 4.2.1 종합 Analytics Manager
```typescript
// src/analytics/AnalyticsManager.ts
export class AnalyticsManager {
    // 핵심 게임 이벤트 추적
    public static trackRunStarted(playerId: string, runConfig: RunConfiguration): void {
        this.sendEvent('run_started', {
            player_id: playerId,
            player_power: runConfig.playerPower,
            stage_requirements: runConfig.stageRequirements,
            equipped_runes: runConfig.selectedRunes.map(r => r.id),
            timestamp: Date.now()
        });
    }
    
    public static trackRunCompleted(playerId: string, result: RunResult): void {
        this.sendEvent('run_completed', {
            player_id: playerId,
            success: result.success,
            stages_completed: result.stagesCompleted,
            total_score: result.totalScore,
            duration_seconds: result.durationMs / 1000,
            runes_collected: result.runesCollected,
            power_gained: result.powerGained,
            timestamp: Date.now()
        });
    }
    
    public static trackRuneSelected(playerId: string, rune: Rune, alternatives: Rune[]): void {
        this.sendEvent('rune_selected', {
            player_id: playerId,
            selected_rune: rune.id,
            rune_rarity: rune.rarity,
            alternatives: alternatives.map(r => r.id),
            stage_number: RunManager.getCurrentStage(),
            timestamp: Date.now()
        });
    }
    
    // BM 관련 이벤트
    public static trackPurchaseOffered(playerId: string, offer: PurchaseOffer, showReason: string): void {
        this.sendEvent('purchase_offered', {
            player_id: playerId,
            offer_id: offer.id,
            offer_type: offer.type,
            price_usd: offer.priceUSD,
            show_reason: showReason,
            player_energy: EnergyManager.getCurrentEnergy(),
            player_loss_streak: PlayerManager.getLossStreak(playerId),
            timestamp: Date.now()
        });
    }
    
    // 퍼널 분석
    public static async generateConversionFunnel(): Promise<ConversionFunnel> {
        const funnelData = await this.query(`
            SELECT 
                COUNT(DISTINCT CASE WHEN event_type = 'game_start' THEN player_id END) as game_starts,
                COUNT(DISTINCT CASE WHEN event_type = 'run_started' THEN player_id END) as run_starts,
                COUNT(DISTINCT CASE WHEN event_type = 'run_completed' AND success = true THEN player_id END) as run_completions,
                COUNT(DISTINCT CASE WHEN event_type = 'purchase_offered' THEN player_id END) as purchase_offers,
                COUNT(DISTINCT CASE WHEN event_type = 'purchase_completed' THEN player_id END) as purchases
            FROM analytics_events 
            WHERE timestamp >= ?
        `, [Date.now() - 7 * 24 * 60 * 60 * 1000]);
        
        return {
            gameStart: funnelData.game_starts,
            runStart: funnelData.run_starts, 
            runCompletion: funnelData.run_completions,
            purchaseOffer: funnelData.purchase_offers,
            purchase: funnelData.purchases,
            
            // 전환율 계산
            startToRun: funnelData.run_starts / funnelData.game_starts,
            runToCompletion: funnelData.run_completions / funnelData.run_starts,
            offerToPurchase: funnelData.purchases / funnelData.purchase_offers,
            overallConversion: funnelData.purchases / funnelData.game_starts
        };
    }
}
```

## 📊 성공 지표 추적 시스템

### 5.1 KPI 대시보드 구현
```html
<!-- 운영진용 실시간 대시보드 -->
<!DOCTYPE html>
<html>
<head>
    <title>Sweet Soul Puzzle - Live Dashboard</title>
    <script src="chart.js"></script>
</head>
<body>
    <div class="dashboard">
        <div class="kpi-grid">
            <div class="kpi-card revenue">
                <h3>실시간 매출</h3>
                <div class="kpi-value" id="revenue">$0</div>
                <div class="kpi-change" id="revenue-change">+0%</div>
            </div>
            
            <div class="kpi-card users">
                <h3>활성 사용자</h3>
                <div class="kpi-value" id="dau">0</div>
                <div class="kpi-trend" id="dau-trend">📈</div>
            </div>
            
            <div class="kpi-card conversion">
                <h3>전환율</h3>
                <div class="kpi-value" id="conversion">0%</div>
                <div class="kpi-target">목표: 15%</div>
            </div>
            
            <div class="kpi-card retention">
                <h3>D7 리텐션</h3>
                <div class="kpi-value" id="retention">0%</div>
                <div class="kpi-target">목표: 20%</div>
            </div>
        </div>
        
        <div class="charts-grid">
            <div class="chart-container">
                <canvas id="hourly-revenue-chart"></canvas>
            </div>
            
            <div class="chart-container"> 
                <canvas id="run-completion-chart"></canvas>
            </div>
        </div>
        
        <div class="alerts-panel">
            <h3>실시간 알림</h3>
            <div id="alerts-list">
                <!-- 자동으로 업데이트되는 알림 목록 -->
            </div>
        </div>
    </div>
</body>
</html>
```

## 🎯 최종 목표 및 성공 지표

### 소프트 런칭 목표 (3개월)
- **DAU**: 1,000-5,000명
- **월매출**: $10K-30K  
- **D7 리텐션**: 18-25%
- **전환율**: 12-18%
- **평균 세션**: 12-15분
- **스토어 평점**: 4.0+ 별점

### 글로벌 런칭 목표 (6개월)
- **DAU**: 50,000-100,000명
- **월매출**: $100K-300K
- **D7 리텐션**: 20-30%
- **전환율**: 15-22% 
- **LTV**: $8-15 (30일)
- **스토어 평점**: 4.3+ 별점

---

## 📋 개발 체크리스트

### Phase 1 완료 조건
- [ ] RunManager 구현 및 테스트
- [ ] 룬 시스템 완전 구현 (50+ 룬)
- [ ] 3선택 UI 및 애니메이션  
- [ ] 기본 장비 시스템 (20+ 장비)
- [ ] 에너지 시스템 확장
- [ ] 기존 Sweet Puzzle과 호환성 테스트

### Phase 2 완료 조건  
- [ ] 가챠 시스템 (천장 포함)
- [ ] Google Play Billing 연동
- [ ] 구매 동기 분석 시스템
- [ ] 개인화 제안 시스템
- [ ] 광고 SDK 통합
- [ ] 결제 보안 검증

### Phase 3 완료 조건
- [ ] 시뮬레이션 시스템 (10만 플레이어)
- [ ] A/B 테스트 프레임워크
- [ ] 자동 밸런싱 도구
- [ ] 운영 대시보드
- [ ] 알림 시스템
- [ ] 성능 최적화

### Phase 4 완료 조건
- [ ] 소프트 런칭 빌드
- [ ] 실시간 분석 시스템
- [ ] 긴급 대응 시스템
- [ ] 사용자 지원 도구
- [ ] 스토어 등록 준비
- [ ] 마케팅 자료 완성

Sweet Puzzle의 소울라이크 로그라이크 변형으로 **99번 문서의 데이터 기반 공정성**과 **31번 문서의 수학적 정밀성**을 결합하여 **모바일 퍼즐 게임의 새로운 장르**를 개척하고, **지속 가능한 월매출 $100K+ 달성**이 가능한 프리미엄 게임을 만들어보겠습니다!

**🎯 최종 목표: 데이터 기반 자동 밸런싱으로 궁수의 전설을 넘어서는 공정한 퍼즐 게임 혁신작 완성** 🚀