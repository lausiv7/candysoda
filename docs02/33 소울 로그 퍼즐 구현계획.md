# 33. Sweet Puzzle ì†Œìš¸ë¼ì´í¬ ë¡œê·¸ë¼ì´í¬ êµ¬í˜„ê³„íš

## ğŸ“‹ ê°œìš”

32ë²ˆ ì„¤ê³„ ë¬¸ì„œ + **99ë²ˆ BM_LevelDesign.md**ë¥¼ ë°”íƒ•ìœ¼ë¡œ ê¸°ì¡´ Sweet Puzzle ì½”ë“œë² ì´ìŠ¤ë¥¼ **ë°ì´í„° ê¸°ë°˜ ìë™ ë°¸ëŸ°ì‹± ì†Œìš¸ë¼ì´í¬ ë¡œê·¸ë¼ì´í¬** ê²Œì„ìœ¼ë¡œ ì „í™˜í•˜ëŠ” êµ¬ì²´ì ì¸ êµ¬í˜„ ê³„íšì„œì…ë‹ˆë‹¤.

### ğŸ¯ êµ¬í˜„ ì „ëµ (99ë²ˆ ë¬¸ì„œ ê¸°ë°˜)

**ê¸°ì¡´ ì½”ë“œ ìµœëŒ€ í™œìš©** + **99ë²ˆ ë°ì´í„° ê¸°ë°˜ íŠœë‹** + **ì ì§„ì  ê¸°ëŠ¥ ì¶”ê°€** ë°©ì‹ìœ¼ë¡œ ë¦¬ìŠ¤í¬ë¥¼ ìµœì†Œí™”í•˜ë©´ì„œ **ê³µì •í•œ ì„±ì¥ ê²½í—˜**ì„ ì œê³µí•˜ëŠ” í˜ì‹ ì ì¸ ê²Œì„í”Œë ˆì´ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤.

## ğŸ—ï¸ Phase 1: ë¡œê·¸ë¼ì´í¬ í•µì‹¬ ì‹œìŠ¤í…œ êµ¬í˜„ (4-6ì£¼)

### 1.1 RunManager ì‹œìŠ¤í…œ êµ¬í˜„

#### 1.1.1 ìƒˆë¡œìš´ íŒŒì¼ ìƒì„±
```typescript
// src/managers/RunManager.ts
import { GameBoard } from '../puzzle/GameBoard';
import { StageConfig, RunResult, Rune } from '../types/SoulLikeTypes';

export class RunManager {
    private currentStage: number = 1;
    private selectedRunes: Rune[] = [];
    private runStartPower: number;
    private stageConfigs: StageConfig[];

    constructor() {
        this.initializeStageConfigs();
    }

    // 99ë²ˆ ë¬¸ì„œ êµ¬ê°„ë³„ ë‚œì´ë„ + 31ë²ˆ ë¬¸ì„œ ê³µì‹ í†µí•©
    private calculateStageRequirement(stage: number): number {
        // 99ë²ˆ ë¬¸ì„œ êµ¬ê°„ë³„ ì„¤ì •
        const stageBracket = this.getStageBracket(stage);
        const baseReq = stageBracket.base_requirement;
        const growthRate = stageBracket.growth_rate;
        
        const stageInBracket = stage - stageBracket.start_stage + 1;
        return Math.floor(baseReq * Math.pow(growthRate, stageInBracket - 1));
    }
    
    private getStageBracket(stage: number): StageBracket {
        if (stage <= 5) return {base_requirement: 100, growth_rate: 1.05, start_stage: 1};
        if (stage <= 20) return {base_requirement: 120, growth_rate: 1.08, start_stage: 6};
        if (stage <= 40) return {base_requirement: 180, growth_rate: 1.12, start_stage: 21};
        return {base_requirement: 300, growth_rate: 1.15, start_stage: 41};
    }

    async startRun(playerPower: number): Promise<void> {
        // ì—ë„ˆì§€ ì°¨ê° (ê¸°ì¡´ ì½”ë“œ í™œìš©)
        await EnergyManager.consumeEnergy(1);
        
        this.runStartPower = playerPower;
        this.selectedRunes = [];
        
        for (let stage = 1; stage <= 5; stage++) {
            const stageResult = await this.executeStage(stage);
            
            if (!stageResult.success) {
                return this.handleRunFailure(stage, stageResult);
            }
            
            // ë£¬ ì„ íƒ (ë³´ìŠ¤ ìŠ¤í…Œì´ì§€ ì œì™¸)
            if (stage < 5) {
                const selectedRune = await this.presentRuneChoice(stage);
                this.selectedRunes.push(selectedRune);
                this.applyRuneToNextStage(selectedRune);
            }
        }
        
        return this.completeRun();
    }
}
```

#### 1.1.2 ê¸°ì¡´ GameBoard.ts í™•ì¥
```typescript
// ê¸°ì¡´ GameBoard.tsì— ì¶”ê°€í•  ë©”ì„œë“œë“¤
export class GameBoard {
    // ìƒˆë¡œ ì¶”ê°€ë˜ëŠ” ì†ì„±ë“¤
    public activeRunes: Rune[] = [];
    public stageMultiplier: number = 1.0;
    public timeBonus: number = 0;
    
    // ë£¬ íš¨ê³¼ ì ìš© ë©”ì„œë“œ ì¶”ê°€
    public applyRuneEffects(): void {
        for (const rune of this.activeRunes) {
            switch (rune.type) {
                case 'TIME_EXTENSION':
                    this.timeLimit += rune.value;
                    break;
                case 'SPECIAL_BLOCK_BOOST':
                    this.specialBlockGenerationRate *= (1 + rune.value);
                    break;
                case 'COMBO_MASTER':
                    this.comboMultiplier *= (1 + rune.value);
                    break;
                case 'POWER_START':
                    this.generateInitialSpecialBlocks(rune.value);
                    break;
            }
        }
    }
    
    // ê¸°ì¡´ startLevel ë©”ì„œë“œ í™•ì¥
    public startLevel(levelConfig: any): void {
        // ê¸°ì¡´ ë¡œì§ ì‹¤í–‰
        super.startLevel(levelConfig);
        
        // ë£¬ íš¨ê³¼ ì ìš©
        this.applyRuneEffects();
        
        // ì†Œìš¸ë¼ì´í¬ ìŠ¤í…Œì´ì§€ ë‚œì´ë„ ì ìš©
        this.applyStageModifiers();
    }
}
```

### 1.2 ë£¬ ì‹œìŠ¤í…œ êµ¬í˜„

#### 1.2.1 ë£¬ ë°ì´í„° ëª¨ë¸
```typescript
// src/types/RuneTypes.ts
export enum RuneType {
    TIME_EXTENSION = 'TIME_EXTENSION',
    SPECIAL_BLOCK_BOOST = 'SPECIAL_BLOCK_BOOST', 
    COMBO_MASTER = 'COMBO_MASTER',
    POWER_START = 'POWER_START',
    SCORE_MULTIPLIER = 'SCORE_MULTIPLIER',
    MOVE_BONUS = 'MOVE_BONUS'
}

export enum RuneRarity {
    COMMON = 'COMMON',
    RARE = 'RARE', 
    EPIC = 'EPIC',
    LEGENDARY = 'LEGENDARY'
}

export interface Rune {
    id: string;
    type: RuneType;
    rarity: RuneRarity;
    name: string;
    description: string;
    value: number;
    icon: string;
    flavorText: string;
}

// ë£¬ ë°ì´í„°ë² ì´ìŠ¤
export const RUNE_DATABASE: Record<RuneType, Rune[]> = {
    [RuneType.TIME_EXTENSION]: [
        {
            id: 'time_common',
            type: RuneType.TIME_EXTENSION,
            rarity: RuneRarity.COMMON,
            name: 'ì‹œê°„ì˜ ì¡°ê°',
            description: 'ì œí•œì‹œê°„ +15ì´ˆ',
            value: 15,
            icon: 'â³',
            flavorText: 'ì‹œê°„ì€ ê°€ì¥ ì†Œì¤‘í•œ ìì›ì´ë‹¤.'
        },
        {
            id: 'time_rare',
            type: RuneType.TIME_EXTENSION,
            rarity: RuneRarity.RARE,
            name: 'ì‹œê°„ì˜ íë¦„',
            description: 'ì œí•œì‹œê°„ +25ì´ˆ',
            value: 25,
            icon: 'â°',
            flavorText: 'ì‹œê°„ì„ ë‹¤ìŠ¤ë¦¬ëŠ” ìê°€ ìŠ¹ë¦¬í•œë‹¤.'
        }
    ],
    // ... ë‹¤ë¥¸ ë£¬ íƒ€ì…ë“¤
};
```

#### 1.2.2 ë£¬ ì„ íƒ UI ì»´í¬ë„ŒíŠ¸
```typescript
// src/ui/RuneSelectionUI.ts
export class RuneSelectionUI {
    private selectionContainer: HTMLElement;
    private onRuneSelected: (rune: Rune) => void;
    
    constructor(onRuneSelected: (rune: Rune) => void) {
        this.onRuneSelected = onRuneSelected;
        this.createSelectionUI();
    }
    
    public showRuneChoices(runes: Rune[], canReroll: boolean = true): Promise<Rune> {
        return new Promise((resolve) => {
            this.renderRuneOptions(runes);
            
            if (canReroll) {
                this.addRerollButton(() => {
                    // 300ì½”ì¸ìœ¼ë¡œ ì¬ì„ íƒ (BM í¬ì¸íŠ¸)
                    this.showPaymentModal('rune_reroll', 300);
                });
            }
            
            this.onRuneSelected = resolve;
            this.show();
        });
    }
    
    private renderRuneOptions(runes: Rune[]): void {
        const runeContainer = this.selectionContainer.querySelector('.rune-options');
        runeContainer.innerHTML = '';
        
        runes.forEach((rune, index) => {
            const runeCard = this.createRuneCard(rune, index);
            runeContainer.appendChild(runeCard);
        });
    }
    
    private createRuneCard(rune: Rune, index: number): HTMLElement {
        const card = document.createElement('div');
        card.className = `rune-card rarity-${rune.rarity.toLowerCase()}`;
        
        card.innerHTML = `
            <div class="rune-icon">${rune.icon}</div>
            <div class="rune-name">${rune.name}</div>
            <div class="rune-description">${rune.description}</div>
            <div class="rune-rarity">${rune.rarity}</div>
            <div class="rune-flavor">${rune.flavorText}</div>
        `;
        
        card.addEventListener('click', () => {
            this.selectRune(rune);
        });
        
        // ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼
        card.style.animationDelay = `${index * 0.2}s`;
        card.classList.add('rune-appear');
        
        return card;
    }
}
```

### 1.3 ì¥ë¹„ ì‹œìŠ¤í…œ ê¸°ì´ˆ êµ¬í˜„

#### 1.3.1 ì¥ë¹„ ë°ì´í„° ëª¨ë¸
```typescript
// src/types/EquipmentTypes.ts
export enum EquipmentSlot {
    WEAPON = 'WEAPON',
    ARMOR = 'ARMOR', 
    ACCESSORY = 'ACCESSORY'
}

export interface Equipment {
    id: string;
    slot: EquipmentSlot;
    name: string;
    rarity: RuneRarity;
    level: number;
    maxLevel: number;
    basePower: number;
    effects: EquipmentEffect[];
    upgradeRequirements: UpgradeRequirement[];
}

export interface EquipmentEffect {
    type: 'POWER' | 'SPECIAL_RATE' | 'TIME_BONUS' | 'SCORE_MULT' | 'ENERGY_SAVE';
    value: number;
    description: string;
}

// ì¥ë¹„ ë°ì´í„°ë² ì´ìŠ¤
export const EQUIPMENT_DATABASE: Equipment[] = [
    {
        id: 'weapon_001',
        slot: EquipmentSlot.WEAPON,
        name: 'ë§ˆë²• ì§€íŒ¡ì´',
        rarity: RuneRarity.COMMON,
        level: 1,
        maxLevel: 10,
        basePower: 25,
        effects: [
            {
                type: 'SPECIAL_RATE',
                value: 0.05,
                description: 'íŠ¹ìˆ˜ë¸”ë¡ ìƒì„±ë¥  +5%'
            }
        ],
        upgradeRequirements: [
            { resource: 'COINS', amount: 1000 },
            { resource: 'GEMS', amount: 10 }
        ]
    }
    // ... ë” ë§ì€ ì¥ë¹„ë“¤
];
```

#### 1.3.2 EquipmentManager êµ¬í˜„
```typescript
// src/managers/EquipmentManager.ts
export class EquipmentManager {
    private equippedItems: Map<EquipmentSlot, Equipment> = new Map();
    private inventory: Equipment[] = [];
    
    public calculateTotalPower(): number {
        let totalPower = 100; // ê¸°ë³¸ ì „íˆ¬ë ¥
        
        this.equippedItems.forEach((equipment) => {
            totalPower += this.calculateEquipmentPower(equipment);
        });
        
        return totalPower;
    }
    
    private calculateEquipmentPower(equipment: Equipment): number {
        const levelMultiplier = 1 + (equipment.level - 1) * 0.1;
        const rarityMultiplier = this.getRarityMultiplier(equipment.rarity);
        
        return equipment.basePower * levelMultiplier * rarityMultiplier;
    }
    
    public upgradeEquipment(equipmentId: string): Promise<boolean> {
        const equipment = this.findEquipmentById(equipmentId);
        if (!equipment || equipment.level >= equipment.maxLevel) {
            return Promise.resolve(false);
        }
        
        // ì—…ê·¸ë ˆì´ë“œ ë¹„ìš© ê³„ì‚° (31ë²ˆ ë¬¸ì„œ ê³µì‹)
        const upgradeCost = this.calculateUpgradeCost(equipment);
        
        return PaymentManager.spendResources(upgradeCost)
            .then(() => {
                equipment.level++;
                this.saveEquipmentData();
                return true;
            });
    }
}
```

### 1.4 ì—ë„ˆì§€(ë²ˆê°œ) ì‹œìŠ¤í…œ êµ¬í˜„

#### 1.4.1 EnergyManager í™•ì¥
```typescript
// ê¸°ì¡´ EnergyManagerë¥¼ í™•ì¥í•˜ì—¬ ì†Œìš¸ë¼ì´í¬ íŠ¹í™” ê¸°ëŠ¥ ì¶”ê°€
export class EnergyManager {
    private static readonly MAX_ENERGY = 5;
    private static readonly RECHARGE_INTERVAL = 25 * 60 * 1000; // 25ë¶„
    
    // ê¸°ì¡´ ë©”ì„œë“œë“¤...
    
    // ìƒˆë¡œ ì¶”ê°€ë˜ëŠ” ë©”ì„œë“œë“¤
    public static async consumeEnergyForRun(): Promise<boolean> {
        const currentEnergy = await this.getCurrentEnergy();
        
        if (currentEnergy <= 0) {
            // ì—ë„ˆì§€ ë¶€ì¡± ì‹œ êµ¬ë§¤ ì œì•ˆ (BM í¬ì¸íŠ¸)
            const purchaseOffered = await this.offerEnergyPurchase();
            return purchaseOffered;
        }
        
        await this.setCurrentEnergy(currentEnergy - 1);
        await this.updateLastUsedTime();
        
        return true;
    }
    
    private static async offerEnergyPurchase(): Promise<boolean> {
        // 31ë²ˆ ë¬¸ì„œì˜ êµ¬ë§¤ ë™ê¸° ë¶„ì„ ì ìš©
        const player = await PlayerManager.getCurrentPlayer();
        const purchaseProbability = PurchaseManager.calculatePurchaseProbability(player);
        
        if (purchaseProbability > 0.15) {
            return await this.showEnergyPurchaseModal();
        }
        
        return false;
    }
    
    private static async showEnergyPurchaseModal(): Promise<boolean> {
        const modal = new PurchaseModal({
            title: 'ì—ë„ˆì§€ ë¶€ì¡±!',
            description: 'ëŸ°ì„ ê³„ì†í•˜ë ¤ë©´ ë²ˆê°œê°€ í•„ìš”í•©ë‹ˆë‹¤.',
            offers: [
                {
                    id: 'energy_5',
                    name: 'ë²ˆê°œ 5ê°œ',
                    price: '$0.99',
                    coins: 1000,
                    popular: true
                },
                {
                    id: 'energy_unlimited_1h',
                    name: 'ë¬´ì œí•œ 1ì‹œê°„',
                    price: '$2.99',
                    coins: 3000,
                    bestValue: true
                }
            ]
        });
        
        return await modal.show();
    }
}
```

## ğŸ—ï¸ Phase 2: ê³µì •í•œ BM ì‹œìŠ¤í…œ êµ¬í˜„ (4ì£¼) - 99-01ë²ˆ ë¬¸ì„œ ìœ¤ë¦¬ì  ìˆ˜ìµí™” ì „ëµ

### 2.1 ê°€ì±  ì‹œìŠ¤í…œ êµ¬í˜„

#### 2.1.1 GachaManager ìƒì„±
```typescript
// src/managers/GachaManager.ts
export class GachaManager {
    private static readonly GACHA_RATES = {
        [RuneRarity.COMMON]: 0.60,
        [RuneRarity.RARE]: 0.25,
        [RuneRarity.EPIC]: 0.12,
        [RuneRarity.LEGENDARY]: 0.03
    };
    
    private static readonly PITY_THRESHOLD = 50;
    
    public static async performSinglePull(playerId: string): Promise<Equipment> {
        // ë¹„ìš© ì°¨ê°
        await PaymentManager.spendCoins(playerId, 500);
        
        // ì²œì¥ ì‹œìŠ¤í…œ í™•ì¸
        const pityCount = await this.getPityCount(playerId);
        let guaranteedRarity: RuneRarity | null = null;
        
        if (pityCount >= this.PITY_THRESHOLD) {
            guaranteedRarity = RuneRarity.EPIC;
            await this.resetPityCount(playerId);
        }
        
        // í™•ë¥ ì— ë”°ë¥¸ ì¥ë¹„ ì¶”ì²¨
        const rarity = guaranteedRarity || this.rollRarity();
        const equipment = this.selectRandomEquipment(rarity);
        
        // ì¸ë²¤í† ë¦¬ì— ì¶”ê°€
        await InventoryManager.addEquipment(playerId, equipment);
        
        // ì²œì¥ ì¹´ìš´í„° ì¦ê°€
        if (!guaranteedRarity) {
            await this.incrementPityCount(playerId);
        }
        
        // ì• ë„ë¦¬í‹±ìŠ¤ ì´ë²¤íŠ¸
        AnalyticsManager.trackGachaPull(playerId, equipment.rarity, pityCount);
        
        return equipment;
    }
    
    public static async perform10Pull(playerId: string): Promise<Equipment[]> {
        // 10ì—°ì°¨ í• ì¸ (4500ì½”ì¸ = 500x9)
        await PaymentManager.spendCoins(playerId, 4500);
        
        const results: Equipment[] = [];
        
        for (let i = 0; i < 10; i++) {
            // ë§ˆì§€ë§‰ ë½‘ê¸°ëŠ” ë ˆì–´ ì´ìƒ ë³´ì¥
            const guaranteedRare = i === 9;
            const equipment = await this.performSinglePullInternal(playerId, guaranteedRare);
            results.push(equipment);
        }
        
        return results;
    }
}
```

#### 2.1.2 ê°€ì±  UI êµ¬í˜„
```typescript
// src/ui/GachaUI.ts
export class GachaUI {
    public showGachaResults(equipments: Equipment[]): Promise<void> {
        return new Promise((resolve) => {
            // í™”ë ¤í•œ ë½‘ê¸° ì• ë‹ˆë©”ì´ì…˜
            this.playGachaAnimation(equipments).then(() => {
                // ê²°ê³¼ í‘œì‹œ
                this.displayResults(equipments);
                
                // ì¶”ê°€ ë½‘ê¸° ìœ ë„ (BM)
                if (equipments.some(e => e.rarity === RuneRarity.LEGENDARY)) {
                    this.showCongratuationsModal();
                } else {
                    this.showContinuePullingSuggestion();
                }
                
                resolve();
            });
        });
    }
    
    private async playGachaAnimation(equipments: Equipment[]): Promise<void> {
        // ê¶ìˆ˜ì˜ ì „ì„¤ ìŠ¤íƒ€ì¼ í™”ë ¤í•œ ì• ë‹ˆë©”ì´ì…˜
        const container = document.getElementById('gacha-animation');
        
        for (let i = 0; i < equipments.length; i++) {
            const equipment = equipments[i];
            
            // ìˆ˜ì •êµ¬ ê¹¨ì§€ëŠ” íš¨ê³¼
            await this.playCrystalBreakAnimation();
            
            // ì¥ë¹„ ë“±ì¥ ì• ë‹ˆë©”ì´ì…˜ 
            await this.playEquipmentRevealAnimation(equipment);
            
            // ë ˆì–´ë„ë³„ íŠ¹ìˆ˜ íš¨ê³¼
            if (equipment.rarity === RuneRarity.LEGENDARY) {
                await this.playLegendaryEffect();
                AudioManager.playSound('legendary_pull');
            }
            
            await this.delay(500); // ê°„ê²©
        }
    }
}
```

### 2.2 êµ¬ë§¤ ë™ê¸° ë¶„ì„ ì‹œìŠ¤í…œ

#### 2.2.1 PurchaseAnalytics êµ¬í˜„
```typescript
// src/analytics/PurchaseAnalytics.ts
export class PurchaseAnalytics {
    // 31ë²ˆ ë¬¸ì„œì˜ ë¡œì§€ìŠ¤í‹± íšŒê·€ ëª¨ë¸ êµ¬í˜„
    public static calculatePurchaseProbability(player: Player): number {
        // íŠ¹ì„± ì¶”ì¶œ
        const pf = this.calculateProgressFriction(player);
        const ls = Math.min(player.lossStreak, 10); // ìƒí•œ ì„¤ì •
        const rs = this.calculateResourceScarcity(player);
        const rm = this.getCurrentRewardMagnitude(player);
        const pvs = this.getPlayerValueSegment(player);
        const recent_success = Math.max(0, player.recentSuccessCount - 2);
        
        // 31ë²ˆ ë¬¸ì„œ ê³µì‹ ì ìš©
        const b0 = -3.0, b1 = 2.0, b2 = 0.5, b3 = 1.5, b4 = 1.0, b5 = 2.5, b6 = -1.0;
        
        const logit = b0 + b1*pf + b2*ls + b3*rs + b4*rm + b5*pvs + b6*recent_success;
        
        return 1 / (1 + Math.exp(-logit));
    }
    
    private static calculateProgressFriction(player: Player): number {
        const effectivePower = player.totalPower * 0.6 + player.skillRating * 0.4;
        const currentStageRequirement = RunManager.getCurrentStageRequirement();
        
        const gap = effectivePower / currentStageRequirement;
        return Math.max(0, 1 - gap); // Gap < 1ì¼ ë•Œë§Œ ì¢Œì ˆê° ë°œìƒ
    }
    
    private static calculateResourceScarcity(player: Player): number {
        const energyShortageDuration = Date.now() - player.lastEnergyFullTime;
        const hoursWithoutEnergy = energyShortageDuration / (1000 * 60 * 60);
        
        return Math.min(hoursWithoutEnergy / 2, 5); // ìµœëŒ€ 5ì 
    }
}
```

#### 2.2.2 Dynamic Offer System
```typescript
// src/systems/DynamicOfferSystem.ts
export class DynamicOfferSystem {
    public static async evaluateAndShowOffer(player: Player): Promise<void> {
        const probability = PurchaseAnalytics.calculatePurchaseProbability(player);
        
        // 15% ì´ìƒì¼ ë•Œë§Œ ì œì•ˆ í‘œì‹œ
        if (probability < 0.15) return;
        
        const offerType = this.selectBestOfferType(player);
        const offer = await this.generatePersonalizedOffer(offerType, player);
        
        // ì œì•ˆ í‘œì‹œ
        await this.showOfferModal(offer, probability);
        
        // ë¶„ì„ ë°ì´í„° ìˆ˜ì§‘
        AnalyticsManager.trackOfferShown(player.id, offerType, probability);
    }
    
    private static selectBestOfferType(player: Player): OfferType {
        // ìƒí™©ì— ë§ëŠ” ìµœì  ì œì•ˆ ì„ íƒ
        if (player.energyCount <= 0) {
            return OfferType.ENERGY_PACKAGE;
        } else if (player.lossStreak >= 3) {
            return OfferType.POWER_UP_PACKAGE;
        } else if (player.nearMilestone) {
            return OfferType.PREMIUM_GACHA;
        } else {
            return OfferType.STARTER_BUNDLE;
        }
    }
}
```

### 2.3 ê²°ì œ ì‹œìŠ¤í…œ í†µí•©

#### 2.3.1 PaymentManager í™•ì¥
```typescript
// src/managers/PaymentManager.ts  
export class PaymentManager {
    // Google Play Billing ì—°ë™
    public static async initializeBilling(): Promise<void> {
        if (PlatformManager.isAndroid()) {
            await this.initializeGooglePlayBilling();
        } else if (PlatformManager.isWeb()) {
            await this.initializeWebPayments();
        }
    }
    
    public static async purchaseProduct(productId: string): Promise<boolean> {
        try {
            // ê²°ì œ ì „ ê²€ì¦
            const isValidPurchase = await this.validatePurchaseRequest(productId);
            if (!isValidPurchase) return false;
            
            // í”Œë«í¼ë³„ ê²°ì œ ì²˜ë¦¬
            const purchaseResult = await this.processPlatformPayment(productId);
            
            if (purchaseResult.success) {
                // ì•„ì´í…œ ì§€ê¸‰
                await this.fulfillPurchase(purchaseResult.purchaseToken, productId);
                
                // ë¶„ì„ ë°ì´í„°
                AnalyticsManager.trackPurchase(productId, purchaseResult.price);
                
                return true;
            }
            
            return false;
        } catch (error) {
            console.error('Purchase failed:', error);
            return false;
        }
    }
    
    private static async fulfillPurchase(purchaseToken: string, productId: string): Promise<void> {
        const productConfig = PRODUCT_CATALOG[productId];
        
        switch (productConfig.type) {
            case 'ENERGY':
                await EnergyManager.addEnergy(productConfig.amount);
                break;
            case 'COINS':
                await CurrencyManager.addCoins(productConfig.amount);
                break;
            case 'GACHA_TICKETS':
                await GachaManager.addTickets(productConfig.amount);
                break;
            case 'PREMIUM_BUNDLE':
                await this.fulfillPremiumBundle(productConfig);
                break;
        }
    }
}
```

## ğŸ—ï¸ Phase 3: ë°¸ëŸ°ì‹± ë° ìµœì í™” (3-4ì£¼)

### 3.1 ì‹œë®¬ë ˆì´ì…˜ ì‹œìŠ¤í…œ êµ¬í˜„

#### 3.1.1 GameSimulator êµ¬í˜„ (31ë²ˆ ë¬¸ì„œ ê¸°ë°˜)
```typescript
// src/simulation/GameSimulator.ts
export class GameSimulator {
    public static async runBalanceSimulation(config: SimulationConfig): Promise<SimulationResult> {
        const results: PlayerSimulationResult[] = [];
        
        // í”Œë ˆì´ì–´ ì„¸ê·¸ë¨¼íŠ¸ë³„ ì‹œë®¬ë ˆì´ì…˜
        for (const segment of config.playerSegments) {
            const segmentResults = await this.simulatePlayerSegment(segment, config);
            results.push(...segmentResults);
        }
        
        return this.analyzeSimulationResults(results);
    }
    
    private static async simulatePlayerSegment(
        segment: PlayerSegment, 
        config: SimulationConfig
    ): Promise<PlayerSimulationResult[]> {
        const results: PlayerSimulationResult[] = [];
        
        for (let i = 0; i < segment.playerCount; i++) {
            // 31ë²ˆ ë¬¸ì„œì˜ í”Œë ˆì´ì–´ ëª¨ë¸ë§ ì ìš©
            const player = this.generateSimulatedPlayer(segment);
            const playerResult = await this.simulatePlayerJourney(player, config);
            results.push(playerResult);
        }
        
        return results;
    }
    
    private static generateSimulatedPlayer(segment: PlayerSegment): SimulatedPlayer {
        return {
            id: `sim_${Date.now()}_${Math.random()}`,
            power: this.sampleNormal(segment.powerMean, segment.powerStd),
            skill: this.sampleNormal(segment.skillMean, segment.skillStd),
            pvs: segment.pvs,
            lossStreak: 0,
            totalSpent: 0,
            sessionsPlayed: 0,
            runsCompleted: 0
        };
    }
    
    private static async simulatePlayerJourney(
        player: SimulatedPlayer, 
        config: SimulationConfig
    ): Promise<PlayerSimulationResult> {
        const journey: RunResult[] = [];
        
        // 30ì¼ê°„ ì‹œë®¬ë ˆì´ì…˜
        for (let day = 1; day <= 30; day++) {
            const dailyRuns = this.calculateDailyRuns(player, day);
            
            for (let run = 0; run < dailyRuns; run++) {
                const runResult = await this.simulateRun(player, config);
                journey.push(runResult);
                
                // í”Œë ˆì´ì–´ ìƒíƒœ ì—…ë°ì´íŠ¸
                this.updatePlayerState(player, runResult);
                
                // êµ¬ë§¤ ê²°ì •
                if (!runResult.success) {
                    const purchaseDecision = await this.simulatePurchaseDecision(player);
                    if (purchaseDecision.purchased) {
                        player.totalSpent += purchaseDecision.amount;
                    }
                }
            }
        }
        
        return {
            playerId: player.id,
            segment: this.getPlayerSegmentName(player),
            totalRuns: journey.length,
            completedRuns: journey.filter(r => r.success).length,
            totalSpent: player.totalSpent,
            avgRunDuration: this.calculateAvgRunDuration(journey),
            retentionDays: this.calculateRetentionDays(journey)
        };
    }
}
```

#### 3.1.2 ë°¸ëŸ°ì‹± ìë™í™” ë„êµ¬
```typescript
// src/tools/BalancingTool.ts
export class BalancingTool {
    public static async optimizeStageRequirements(): Promise<OptimizationResult> {
        const currentConfig = ConfigManager.getCurrentBalanceConfig();
        const targetMetrics = {
            avgCompletionRate: 0.45, // 45% ëŸ° ì™„ì£¼ ëª©í‘œ
            f2pCompletionRate: 0.35, // F2P 35% ì™„ì£¼
            whaleCompletionRate: 0.70, // ê³ ê³¼ê¸ˆ 70% ì™„ì£¼
            avgConversionRate: 0.15   // 15% ì „í™˜ìœ¨
        };
        
        let bestConfig = currentConfig;
        let bestScore = await this.evaluateConfig(bestConfig, targetMetrics);
        
        // ìœ ì „ ì•Œê³ ë¦¬ì¦˜ ë°©ì‹ìœ¼ë¡œ ìµœì í™”
        for (let generation = 0; generation < 50; generation++) {
            const candidates = this.generateConfigVariants(bestConfig);
            
            for (const candidate of candidates) {
                const score = await this.evaluateConfig(candidate, targetMetrics);
                if (score > bestScore) {
                    bestConfig = candidate;
                    bestScore = score;
                }
            }
            
            console.log(`Generation ${generation}: Best Score = ${bestScore}`);
        }
        
        return {
            optimizedConfig: bestConfig,
            improvementScore: bestScore,
            recommendedChanges: this.generateRecommendations(currentConfig, bestConfig)
        };
    }
    
    private static async evaluateConfig(
        config: BalanceConfig, 
        targets: TargetMetrics
    ): Promise<number> {
        // ë¹ ë¥¸ ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰ (1000ëª… í”Œë ˆì´ì–´)
        const simulationResult = await GameSimulator.runBalanceSimulation({
            playerSegments: this.getTestPlayerSegments(),
            stageConfigs: config.stageConfigs,
            runeEffects: config.runeEffects,
            maxSimulationDays: 7 // ë¹ ë¥¸ í…ŒìŠ¤íŠ¸ìš©
        });
        
        // ëª©í‘œ ëŒ€ë¹„ ì ìˆ˜ ê³„ì‚°
        const completionScore = this.scoreMetric(
            simulationResult.avgCompletionRate, 
            targets.avgCompletionRate
        );
        
        const conversionScore = this.scoreMetric(
            simulationResult.conversionRate,
            targets.avgConversionRate
        );
        
        const retentionScore = this.scoreMetric(
            simulationResult.d7Retention,
            0.20 // D7 20% ëª©í‘œ
        );
        
        return (completionScore + conversionScore + retentionScore) / 3;
    }
}
```

### 3.2 A/B í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬

#### 3.2.1 ABTestManager êµ¬í˜„
```typescript
// src/ab-testing/ABTestManager.ts
export class ABTestManager {
    private static experiments: Map<string, ABExperiment> = new Map();
    
    public static async initializeExperiments(): Promise<void> {
        // ì„œë²„ì—ì„œ ì‹¤í—˜ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
        const activeExperiments = await APIClient.getActiveExperiments();
        
        for (const experiment of activeExperiments) {
            this.experiments.set(experiment.id, experiment);
            
            // í”Œë ˆì´ì–´ë¥¼ ì‹¤í—˜ ê·¸ë£¹ì— í• ë‹¹
            await this.assignPlayerToExperiment(experiment);
        }
    }
    
    public static getVariant(experimentId: string): string | null {
        const experiment = this.experiments.get(experimentId);
        if (!experiment) return null;
        
        const playerId = PlayerManager.getCurrentPlayerId();
        return experiment.playerAssignments.get(playerId) || null;
    }
    
    // ì‚¬ìš© ì˜ˆì‹œ: ì—ë„ˆì§€ íšŒë³µ ì†ë„ A/B í…ŒìŠ¤íŠ¸
    public static getEnergyRechargeInterval(): number {
        const variant = this.getVariant('energy_recharge_test');
        
        switch (variant) {
            case 'control': return 25 * 60 * 1000; // 25ë¶„
            case 'treatment_a': return 20 * 60 * 1000; // 20ë¶„  
            case 'treatment_b': return 30 * 60 * 1000; // 30ë¶„
            default: return 25 * 60 * 1000; // ê¸°ë³¸ê°’
        }
    }
    
    // ë£¬ ì„ íƒ ê°œìˆ˜ A/B í…ŒìŠ¤íŠ¸
    public static getRuneChoiceCount(): number {
        const variant = this.getVariant('rune_choice_count');
        
        return variant === 'four_choices' ? 4 : 3;
    }
}
```

#### 3.2.2 ì‹¤í—˜ ê²°ê³¼ ë¶„ì„
```typescript
// src/ab-testing/ExperimentAnalyzer.ts
export class ExperimentAnalyzer {
    public static async analyzeExperimentResults(experimentId: string): Promise<ExperimentResult> {
        const experiment = ABTestManager.getExperiment(experimentId);
        const playerData = await this.getExperimentPlayerData(experimentId);
        
        const results: VariantResult[] = [];
        
        for (const variant of experiment.variants) {
            const variantPlayers = playerData.filter(p => p.variant === variant.id);
            
            const metrics = {
                playerCount: variantPlayers.length,
                avgSessionLength: this.calculateAvgSessionLength(variantPlayers),
                conversionRate: this.calculateConversionRate(variantPlayers),
                d1Retention: this.calculateD1Retention(variantPlayers),
                d7Retention: this.calculateD7Retention(variantPlayers),
                arpu: this.calculateARPU(variantPlayers),
                runCompletionRate: this.calculateRunCompletionRate(variantPlayers)
            };
            
            results.push({
                variant: variant.id,
                metrics,
                significance: this.calculateStatisticalSignificance(metrics, experiment.control)
            });
        }
        
        return {
            experimentId,
            variants: results,
            recommendation: this.generateRecommendation(results),
            confidence: this.calculateConfidence(results)
        };
    }
}
```

## ğŸš€ Phase 4: ì†Œí”„íŠ¸ ëŸ°ì¹­ ì¤€ë¹„ (2-3ì£¼)

### 4.1 ìš´ì˜ ëŒ€ì‹œë³´ë“œ êµ¬í˜„

#### 4.1.1 LiveOpsManager
```typescript
// src/liveops/LiveOpsManager.ts
export class LiveOpsManager {
    public static async initializeLiveOps(): Promise<void> {
        // ì‹¤ì‹œê°„ ì„¤ì • ë™ê¸°í™”
        await this.syncRemoteConfig();
        
        // ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        await EventManager.initialize();
        
        // KPI ì¶”ì  ì‹œì‘
        await this.startKPITracking();
    }
    
    public static async updateBalanceParameters(params: BalanceUpdate): Promise<void> {
        // ì‹¤ì‹œê°„ ë°¸ëŸ°ì‹± ì¡°ì • (ì„œë²„ ì¬ì‹œì‘ ì—†ì´)
        
        if (params.stageRequirements) {
            RunManager.updateStageRequirements(params.stageRequirements);
        }
        
        if (params.runeEffects) {
            RuneManager.updateRuneEffects(params.runeEffects);
        }
        
        if (params.gachaRates) {
            GachaManager.updateRates(params.gachaRates);
        }
        
        // ë³€ê²½ì‚¬í•­ ë¡œê·¸
        AnalyticsManager.trackBalanceChange(params);
        
        // í”Œë ˆì´ì–´ì—ê²Œ ì•Œë¦¼ (ì„ íƒì )
        if (params.notifyPlayers) {
            NotificationManager.sendBalanceUpdateNotification();
        }
    }
    
    // ì‹¤ì‹œê°„ KPI ëª¨ë‹ˆí„°ë§
    public static async getRealtimeKPIs(): Promise<RealtimeKPIs> {
        const now = new Date();
        const hour = 60 * 60 * 1000;
        
        return {
            timestamp: now,
            activeUsers: await UserManager.getActiveUserCount(now - hour),
            avgSessionLength: await AnalyticsManager.getAvgSessionLength(now - hour),
            runCompletionRate: await GameManager.getRunCompletionRate(now - hour),
            conversionEvents: await PaymentManager.getConversionEvents(now - hour),
            revenue: await PaymentManager.getHourlyRevenue(now - hour),
            energyPurchases: await PaymentManager.getEnergyPurchases(now - hour),
            gachaPulls: await GachaManager.getHourlyPulls(now - hour)
        };
    }
}
```

#### 4.1.2 ì•Œë¦¼ ë° ì‘ê¸‰ ëŒ€ì‘ ì‹œìŠ¤í…œ
```typescript
// src/monitoring/AlertSystem.ts
export class AlertSystem {
    private static readonly ALERT_THRESHOLDS = {
        crashRate: 0.05,        // 5% ì´ìƒ í¬ë˜ì‹œ
        conversionDrop: 0.30,   // ì „í™˜ìœ¨ 30% í•˜ë½
        revenueDrop: 0.40,      // ë§¤ì¶œ 40% í•˜ë½
        retentionDrop: 0.25,    // ë¦¬í…ì…˜ 25% í•˜ë½
        completionDrop: 0.20    // ì™„ì£¼ìœ¨ 20% í•˜ë½
    };
    
    public static async monitorKPIs(): Promise<void> {
        const currentKPIs = await LiveOpsManager.getRealtimeKPIs();
        const historicalKPIs = await this.getHistoricalBaseline();
        
        const alerts: Alert[] = [];
        
        // ê° ì§€í‘œë³„ ì„ê³„ì¹˜ ê²€ì‚¬
        if (this.isSignificantDrop(currentKPIs.conversionRate, historicalKPIs.conversionRate, this.ALERT_THRESHOLDS.conversionDrop)) {
            alerts.push({
                severity: 'HIGH',
                metric: 'conversion_rate',
                message: `ì „í™˜ìœ¨ ê¸‰ë½ ê°ì§€: ${currentKPIs.conversionRate}% (ê¸°ì¤€: ${historicalKPIs.conversionRate}%)`,
                suggestedAction: 'A/B í…ŒìŠ¤íŠ¸ í™•ì¸, ê²°ì œ ì‹œìŠ¤í…œ ì ê²€'
            });
        }
        
        if (this.isSignificantDrop(currentKPIs.runCompletionRate, historicalKPIs.runCompletionRate, this.ALERT_THRESHOLDS.completionDrop)) {
            alerts.push({
                severity: 'MEDIUM',
                metric: 'run_completion_rate', 
                message: `ëŸ° ì™„ì£¼ìœ¨ í•˜ë½: ${currentKPIs.runCompletionRate}%`,
                suggestedAction: 'ë‚œì´ë„ ë°¸ëŸ°ì‹± ê²€í† , ê¸´ê¸‰ ë²„í”„ ì´ë²¤íŠ¸ ê³ ë ¤'
            });
        }
        
        // ì•Œë¦¼ ë°œì†¡
        if (alerts.length > 0) {
            await this.sendAlertsToOperators(alerts);
            
            // ìë™ ëŒ€ì‘ (ì„¤ì •ëœ ê²½ìš°)
            await this.executeAutomaticResponse(alerts);
        }
    }
    
    private static async executeAutomaticResponse(alerts: Alert[]): Promise<void> {
        for (const alert of alerts) {
            switch (alert.metric) {
                case 'run_completion_rate':
                    // ìë™ìœ¼ë¡œ ëª¨ë“  í”Œë ˆì´ì–´ì—ê²Œ ë²„í”„ ì´ë²¤íŠ¸ í™œì„±í™”
                    await EventManager.activateEmergencyEvent('global_power_boost');
                    break;
                    
                case 'conversion_rate':
                    // í• ì¸ ì´ë²¤íŠ¸ ìë™ í™œì„±í™”
                    await EventManager.activateEmergencyEvent('flash_sale');
                    break;
            }
        }
    }
}
```

### 4.2 ë°ì´í„° ìˆ˜ì§‘ ë° ë¶„ì„ ì‹œìŠ¤í…œ

#### 4.2.1 ì¢…í•© Analytics Manager
```typescript
// src/analytics/AnalyticsManager.ts
export class AnalyticsManager {
    // í•µì‹¬ ê²Œì„ ì´ë²¤íŠ¸ ì¶”ì 
    public static trackRunStarted(playerId: string, runConfig: RunConfiguration): void {
        this.sendEvent('run_started', {
            player_id: playerId,
            player_power: runConfig.playerPower,
            stage_requirements: runConfig.stageRequirements,
            equipped_runes: runConfig.selectedRunes.map(r => r.id),
            timestamp: Date.now()
        });
    }
    
    public static trackRunCompleted(playerId: string, result: RunResult): void {
        this.sendEvent('run_completed', {
            player_id: playerId,
            success: result.success,
            stages_completed: result.stagesCompleted,
            total_score: result.totalScore,
            duration_seconds: result.durationMs / 1000,
            runes_collected: result.runesCollected,
            power_gained: result.powerGained,
            timestamp: Date.now()
        });
    }
    
    public static trackRuneSelected(playerId: string, rune: Rune, alternatives: Rune[]): void {
        this.sendEvent('rune_selected', {
            player_id: playerId,
            selected_rune: rune.id,
            rune_rarity: rune.rarity,
            alternatives: alternatives.map(r => r.id),
            stage_number: RunManager.getCurrentStage(),
            timestamp: Date.now()
        });
    }
    
    // BM ê´€ë ¨ ì´ë²¤íŠ¸
    public static trackPurchaseOffered(playerId: string, offer: PurchaseOffer, showReason: string): void {
        this.sendEvent('purchase_offered', {
            player_id: playerId,
            offer_id: offer.id,
            offer_type: offer.type,
            price_usd: offer.priceUSD,
            show_reason: showReason,
            player_energy: EnergyManager.getCurrentEnergy(),
            player_loss_streak: PlayerManager.getLossStreak(playerId),
            timestamp: Date.now()
        });
    }
    
    // í¼ë„ ë¶„ì„
    public static async generateConversionFunnel(): Promise<ConversionFunnel> {
        const funnelData = await this.query(`
            SELECT 
                COUNT(DISTINCT CASE WHEN event_type = 'game_start' THEN player_id END) as game_starts,
                COUNT(DISTINCT CASE WHEN event_type = 'run_started' THEN player_id END) as run_starts,
                COUNT(DISTINCT CASE WHEN event_type = 'run_completed' AND success = true THEN player_id END) as run_completions,
                COUNT(DISTINCT CASE WHEN event_type = 'purchase_offered' THEN player_id END) as purchase_offers,
                COUNT(DISTINCT CASE WHEN event_type = 'purchase_completed' THEN player_id END) as purchases
            FROM analytics_events 
            WHERE timestamp >= ?
        `, [Date.now() - 7 * 24 * 60 * 60 * 1000]);
        
        return {
            gameStart: funnelData.game_starts,
            runStart: funnelData.run_starts, 
            runCompletion: funnelData.run_completions,
            purchaseOffer: funnelData.purchase_offers,
            purchase: funnelData.purchases,
            
            // ì „í™˜ìœ¨ ê³„ì‚°
            startToRun: funnelData.run_starts / funnelData.game_starts,
            runToCompletion: funnelData.run_completions / funnelData.run_starts,
            offerToPurchase: funnelData.purchases / funnelData.purchase_offers,
            overallConversion: funnelData.purchases / funnelData.game_starts
        };
    }
}
```

## ğŸ“Š ì„±ê³µ ì§€í‘œ ì¶”ì  ì‹œìŠ¤í…œ

### 5.1 KPI ëŒ€ì‹œë³´ë“œ êµ¬í˜„
```html
<!-- ìš´ì˜ì§„ìš© ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ -->
<!DOCTYPE html>
<html>
<head>
    <title>Sweet Soul Puzzle - Live Dashboard</title>
    <script src="chart.js"></script>
</head>
<body>
    <div class="dashboard">
        <div class="kpi-grid">
            <div class="kpi-card revenue">
                <h3>ì‹¤ì‹œê°„ ë§¤ì¶œ</h3>
                <div class="kpi-value" id="revenue">$0</div>
                <div class="kpi-change" id="revenue-change">+0%</div>
            </div>
            
            <div class="kpi-card users">
                <h3>í™œì„± ì‚¬ìš©ì</h3>
                <div class="kpi-value" id="dau">0</div>
                <div class="kpi-trend" id="dau-trend">ğŸ“ˆ</div>
            </div>
            
            <div class="kpi-card conversion">
                <h3>ì „í™˜ìœ¨</h3>
                <div class="kpi-value" id="conversion">0%</div>
                <div class="kpi-target">ëª©í‘œ: 15%</div>
            </div>
            
            <div class="kpi-card retention">
                <h3>D7 ë¦¬í…ì…˜</h3>
                <div class="kpi-value" id="retention">0%</div>
                <div class="kpi-target">ëª©í‘œ: 20%</div>
            </div>
        </div>
        
        <div class="charts-grid">
            <div class="chart-container">
                <canvas id="hourly-revenue-chart"></canvas>
            </div>
            
            <div class="chart-container"> 
                <canvas id="run-completion-chart"></canvas>
            </div>
        </div>
        
        <div class="alerts-panel">
            <h3>ì‹¤ì‹œê°„ ì•Œë¦¼</h3>
            <div id="alerts-list">
                <!-- ìë™ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ëŠ” ì•Œë¦¼ ëª©ë¡ -->
            </div>
        </div>
    </div>
</body>
</html>
```

## ğŸ¯ ìµœì¢… ëª©í‘œ ë° ì„±ê³µ ì§€í‘œ

### ì†Œí”„íŠ¸ ëŸ°ì¹­ ëª©í‘œ (3ê°œì›”)
- **DAU**: 1,000-5,000ëª…
- **ì›”ë§¤ì¶œ**: $10K-30K  
- **D7 ë¦¬í…ì…˜**: 18-25%
- **ì „í™˜ìœ¨**: 12-18%
- **í‰ê·  ì„¸ì…˜**: 12-15ë¶„
- **ìŠ¤í† ì–´ í‰ì **: 4.0+ ë³„ì 

### ê¸€ë¡œë²Œ ëŸ°ì¹­ ëª©í‘œ (6ê°œì›”)
- **DAU**: 50,000-100,000ëª…
- **ì›”ë§¤ì¶œ**: $100K-300K
- **D7 ë¦¬í…ì…˜**: 20-30%
- **ì „í™˜ìœ¨**: 15-22% 
- **LTV**: $8-15 (30ì¼)
- **ìŠ¤í† ì–´ í‰ì **: 4.3+ ë³„ì 

---

## ğŸ“‹ ê°œë°œ ì²´í¬ë¦¬ìŠ¤íŠ¸

### Phase 1 ì™„ë£Œ ì¡°ê±´
- [ ] RunManager êµ¬í˜„ ë° í…ŒìŠ¤íŠ¸
- [ ] ë£¬ ì‹œìŠ¤í…œ ì™„ì „ êµ¬í˜„ (50+ ë£¬)
- [ ] 3ì„ íƒ UI ë° ì• ë‹ˆë©”ì´ì…˜  
- [ ] ê¸°ë³¸ ì¥ë¹„ ì‹œìŠ¤í…œ (20+ ì¥ë¹„)
- [ ] ì—ë„ˆì§€ ì‹œìŠ¤í…œ í™•ì¥
- [ ] ê¸°ì¡´ Sweet Puzzleê³¼ í˜¸í™˜ì„± í…ŒìŠ¤íŠ¸

### Phase 2 ì™„ë£Œ ì¡°ê±´  
- [ ] ê°€ì±  ì‹œìŠ¤í…œ (ì²œì¥ í¬í•¨)
- [ ] Google Play Billing ì—°ë™
- [ ] êµ¬ë§¤ ë™ê¸° ë¶„ì„ ì‹œìŠ¤í…œ
- [ ] ê°œì¸í™” ì œì•ˆ ì‹œìŠ¤í…œ
- [ ] ê´‘ê³  SDK í†µí•©
- [ ] ê²°ì œ ë³´ì•ˆ ê²€ì¦

### Phase 3 ì™„ë£Œ ì¡°ê±´
- [ ] ì‹œë®¬ë ˆì´ì…˜ ì‹œìŠ¤í…œ (10ë§Œ í”Œë ˆì´ì–´)
- [ ] A/B í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬
- [ ] ìë™ ë°¸ëŸ°ì‹± ë„êµ¬
- [ ] ìš´ì˜ ëŒ€ì‹œë³´ë“œ
- [ ] ì•Œë¦¼ ì‹œìŠ¤í…œ
- [ ] ì„±ëŠ¥ ìµœì í™”

### Phase 4 ì™„ë£Œ ì¡°ê±´
- [ ] ì†Œí”„íŠ¸ ëŸ°ì¹­ ë¹Œë“œ
- [ ] ì‹¤ì‹œê°„ ë¶„ì„ ì‹œìŠ¤í…œ
- [ ] ê¸´ê¸‰ ëŒ€ì‘ ì‹œìŠ¤í…œ
- [ ] ì‚¬ìš©ì ì§€ì› ë„êµ¬
- [ ] ìŠ¤í† ì–´ ë“±ë¡ ì¤€ë¹„
- [ ] ë§ˆì¼€íŒ… ìë£Œ ì™„ì„±

Sweet Puzzleì˜ ì†Œìš¸ë¼ì´í¬ ë¡œê·¸ë¼ì´í¬ ë³€í˜•ìœ¼ë¡œ **99ë²ˆ ë¬¸ì„œì˜ ë°ì´í„° ê¸°ë°˜ ê³µì •ì„±**ê³¼ **31ë²ˆ ë¬¸ì„œì˜ ìˆ˜í•™ì  ì •ë°€ì„±**ì„ ê²°í•©í•˜ì—¬ **ëª¨ë°”ì¼ í¼ì¦ ê²Œì„ì˜ ìƒˆë¡œìš´ ì¥ë¥´**ë¥¼ ê°œì²™í•˜ê³ , **ì§€ì† ê°€ëŠ¥í•œ ì›”ë§¤ì¶œ $100K+ ë‹¬ì„±**ì´ ê°€ëŠ¥í•œ í”„ë¦¬ë¯¸ì—„ ê²Œì„ì„ ë§Œë“¤ì–´ë³´ê² ìŠµë‹ˆë‹¤!

**ğŸ¯ ìµœì¢… ëª©í‘œ: ë°ì´í„° ê¸°ë°˜ ìë™ ë°¸ëŸ°ì‹±ìœ¼ë¡œ ê¶ìˆ˜ì˜ ì „ì„¤ì„ ë„˜ì–´ì„œëŠ” ê³µì •í•œ í¼ì¦ ê²Œì„ í˜ì‹ ì‘ ì™„ì„±** ğŸš€